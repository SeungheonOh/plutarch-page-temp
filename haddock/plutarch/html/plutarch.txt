-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch
@version 1.9.0

module Plutarch.DataRepr.Internal.HList.Utils
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[$sel:unLabeled:Labeled] :: Labeled sym a -> a

-- | GADT proof-witness of HList membership, usable as an index
data Elem (a :: k) (as :: [k])
[Here] :: Elem a (a ': as)
[There] :: Elem a as -> Elem a (b ': as)

-- | Indexing type-level lists
type family IndexList (n :: Nat) (l :: [k]) :: k

-- | Indexing list of labeled pairs by label
type family IndexLabel name as

-- | Return the single item from a singleton list
type family SingleItem (as :: [k]) :: k

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

module Plutarch.Internal.PrettyStack
prettyStack :: Text -> CallStack -> Text

module Plutarch.Internal.Witness
witness :: c => Proxy c -> ()

module Plutarch.Pretty.Internal.Config
keywords :: Set Text
indentWidth :: Int

-- | Prefix to use for naming forced builtin functions.
forcedPrefix :: Text

module Plutarch.Pretty.Internal.BuiltinConstant
prettyConstant :: Some (ValueOf DefaultUni) -> Doc ()

module Plutarch.Pretty.Internal.TermUtils
unwrapLamAbs :: Index -> Term name uni fun ann -> (Index, Term name uni fun ann)
unwrapBindings :: [Term name uni fun ann] -> Term name uni fun ann -> ([Term name uni fun ann], Term name uni fun ann)
unwrapApply :: [Term name uni fun ann] -> Term name uni fun ann -> ([Term name uni fun ann], Term name uni fun ann)

-- | Increment the debruijn index of a <a>Var</a>, leave any other AST node
--   unchanged.
incrVar :: Term DeBruijn uni fun () -> Term DeBruijn uni fun ()
pattern PFixAst :: Term name uni fun ()
pattern ComposeAST :: Term DeBruijn uni fun () -> Term DeBruijn uni fun () -> Term DeBruijn uni fun ()
pattern IfThenElseLikeAST :: Term name uni fun () -> Term name uni fun () -> Term name uni fun () -> Term name uni fun () -> Term name uni fun ()

module Plutarch.Pretty.Internal.Types

-- | Notifies the prettifier what "state" the cursor currently is, so it
--   can decide whether or not to wrap the target expression in parens.
--   
--   Normal indicates no parens wrapping is necessary, even for complex
--   expressions.
--   
--   Special indicates complex expressions should be wrapped in parens.
--   
--   Usually, <a>Special</a> just hints at one of three states:
--   
--   <ol>
--   <li>Applying - The expression is being applied like a function.</li>
--   <li>Applied - The expression is being applied as a function
--   argument.</li>
--   <li>Unary arg - The expression is being used as an argument to a high
--   arity unary operator (~ and !).</li>
--   </ol>
data PrettyCursor
Normal :: PrettyCursor
Special :: PrettyCursor
data PrettyState
PrettyState :: Map Index Text -> Set Text -> PrettyCursor -> PrettyState
[$sel:ps'nameMap:PrettyState] :: PrettyState -> Map Index Text
[$sel:ps'names:PrettyState] :: PrettyState -> Set Text
[$sel:ps'cursor:PrettyState] :: PrettyState -> PrettyCursor
type PrettyMonad s = ReaderT (STGenM StdGen s) (StateT PrettyState (ST s))
forkState :: MonadState s m => m b -> m b
normalizeCursor :: PrettyState -> PrettyState
specializeCursor :: PrettyState -> PrettyState
memorizeName :: Text -> PrettyState -> PrettyState

-- | Insert a fresh binding onto the name map, i.e a name at index 0 -
--   incrementing all other indices.
insertName :: Text -> PrettyState -> PrettyState
insertBindings :: [Text] -> PrettyState -> PrettyState
builtinFunAtRef :: Map Index Text -> Index -> Maybe DefaultFun
nameOfRef :: Index -> Map Index Text -> Maybe Text
instance GHC.Show.Show Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Classes.Eq Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Enum.Enum Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Enum.Bounded Plutarch.Pretty.Internal.Types.PrettyCursor

module Plutarch.Pretty.Internal.Name
smartName :: Term DeBruijn uni DefaultFun () -> PrettyMonad s Text
freshVarName :: PrettyMonad s Text

module Plutarch.Script
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
[$sel:unScript:Script] :: Script -> Program DeBruijn DefaultUni DefaultFun ()
serialiseScript :: Script -> ShortByteString
deserialiseScript :: ShortByteString -> Script
instance GHC.Generics.Generic Plutarch.Script.Script
instance GHC.Show.Show Plutarch.Script.Script
instance GHC.Classes.Eq Plutarch.Script.Script

module Plutarch.Internal.Evaluate
uplcVersion :: Version

-- | Evaluate a script with a big budget, returning the trace log and term
--   result.
evalScript :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a huge budget, returning the trace log and term
--   result.
evalScriptHuge :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script without budget limit
--   
--   @since WIP
evalScriptUnlimited :: Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])

-- | Evaluate a script with a specific budget, returning the trace log and
--   term result.
evalScript' :: ExBudget -> Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])
type EvalError = (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun)

module Plutarch.Internal
newtype (:-->) (a :: PType) (b :: PType) (s :: S)
PLam :: (Term s a -> Term s b) -> (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->
data PDelayed (a :: PType) (s :: S)
newtype Term (s :: S) (a :: PType)
Term :: (Word64 -> TermMonad TermResult) -> Term (s :: S) (a :: PType)
[$sel:asRawTerm:Term] :: Term (s :: S) (a :: PType) -> Word64 -> TermMonad TermResult
asClosedRawTerm :: ClosedTerm a -> TermMonad TermResult
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
mapTerm :: (RawTerm -> RawTerm) -> TermResult -> TermResult

-- | Lambda abstraction.
--   
--   Only works with a single argument. Use <tt>plam</tt> instead, to
--   support currying.
plam' :: (Term s a -> Term s b) -> Term s (a :--> b)

-- | Let bindings.
--   
--   This is approximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Lambda Application.
papp :: Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Unsafely coerce the type-tag of a Term.
--   
--   This should mostly be avoided, though it can be safely used to assert
--   known types of Datums, Redeemers or ScriptContext.
punsafeCoerce :: Term s a -> Term s b
punsafeBuiltin :: DefaultFun -> Term s a

-- | <i>Deprecated: Use <tt>pconstant</tt> instead.</i>
punsafeConstant :: Some (ValueOf DefaultUni) -> Term s a
punsafeConstantInternal :: Some (ValueOf DefaultUni) -> Term s a

-- | Compile a (closed) Plutus Term to a usable script
compile :: Config -> ClosedTerm a -> Either Text Script

-- | As <a>compile</a>, but performs UPLC optimizations. Furthermore, this
--   will always elide tracing (as if with <a>NoTracing</a>).
--   
--   @since WIP
compileOptimized :: forall (a :: S -> Type). (forall (s :: S). Term s a) -> Either Text Script
compile' :: TermResult -> UTerm

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a
type Dig = Digest Blake2b_160
hashTerm :: Config -> ClosedTerm a -> Either Text Dig
hashRawTerm :: RawTerm -> Dig
data RawTerm
RVar :: Word64 -> RawTerm
RLamAbs :: Word64 -> RawTerm -> RawTerm
RApply :: RawTerm -> [RawTerm] -> RawTerm
RForce :: RawTerm -> RawTerm
RDelay :: RawTerm -> RawTerm
RConstant :: Some (ValueOf DefaultUni) -> RawTerm
RBuiltin :: DefaultFun -> RawTerm
RCompiled :: UTerm -> RawTerm
RError :: RawTerm
RHoisted :: HoistedTerm -> RawTerm
data TermResult
TermResult :: RawTerm -> [HoistedTerm] -> TermResult
[$sel:getTerm:TermResult] :: TermResult -> RawTerm
[$sel:getDeps:TermResult] :: TermResult -> [HoistedTerm]
data S
SI :: S

-- | Shorthand for Plutarch types.
type PType = S -> Type
pthrow :: HasCallStack => Text -> Term s a

-- | Configuration for Plutarch scripts at compile time. This indicates
--   whether we want to trace, and if so, under what log level and mode.
data Config

-- | Pattern for the config that does no tracing (also the default).
pattern NoTracing :: Config

-- | Pattern for a tracing config, with both its log level and mode.
pattern Tracing :: LogLevel -> TracingMode -> Config

-- | How to trace.
data TracingMode
DetTracing :: TracingMode
DoTracing :: TracingMode
DoTracingAndBinds :: TracingMode

-- | What logging level we want to use.
data LogLevel
LogInfo :: LogLevel
LogDebug :: LogLevel

-- | If the config indicates that we want to trace, get its mode.
tracingMode :: Config -> Maybe TracingMode

-- | If the config indicates that we want to trace, get its log level.
logLevel :: Config -> Maybe LogLevel
pgetConfig :: (Config -> Term s a) -> Term s a
newtype TermMonad m
TermMonad :: ReaderT Config (Either Text) m -> TermMonad m
[$sel:runTermMonad:TermMonad] :: TermMonad m -> ReaderT Config (Either Text) m

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$
instance GHC.Show.Show Plutarch.Internal.HoistedTerm
instance GHC.Show.Show Plutarch.Internal.RawTerm
instance GHC.Show.Show Plutarch.Internal.TracingMode
instance GHC.Classes.Eq Plutarch.Internal.TracingMode
instance GHC.Show.Show Plutarch.Internal.LogLevel
instance GHC.Classes.Eq Plutarch.Internal.LogLevel
instance GHC.Show.Show Plutarch.Internal.Config
instance GHC.Classes.Eq Plutarch.Internal.Config
instance GHC.Base.Monoid Plutarch.Internal.Config
instance GHC.Base.Semigroup Plutarch.Internal.Config
instance GHC.Base.Monad Plutarch.Internal.TermMonad
instance GHC.Base.Applicative Plutarch.Internal.TermMonad
instance GHC.Base.Functor Plutarch.Internal.TermMonad
instance Prettyprinter.Internal.Pretty Plutarch.Internal.Config
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Internal.Config
instance Data.Aeson.Types.FromJSON.FromJSON Plutarch.Internal.Config
instance GHC.Classes.Ord Plutarch.Internal.LogLevel
instance GHC.Base.Semigroup Plutarch.Internal.LogLevel
instance Prettyprinter.Internal.Pretty Plutarch.Internal.LogLevel
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Internal.LogLevel
instance Data.Aeson.Types.FromJSON.FromJSON Plutarch.Internal.LogLevel
instance GHC.Classes.Ord Plutarch.Internal.TracingMode
instance GHC.Base.Semigroup Plutarch.Internal.TracingMode
instance Prettyprinter.Internal.Pretty Plutarch.Internal.TracingMode
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Internal.TracingMode
instance Data.Aeson.Types.FromJSON.FromJSON Plutarch.Internal.TracingMode

module Plutarch.Reducible

-- | This class provides a work-around for partially applying type families
--   of kind <tt>a</tt>, where <tt>a</tt> is either <a>Type</a> or <tt>b
--   -&gt; c</tt> where <tt>c</tt> satisfies the same constraint.
--   
--   Given a type family <tt>F : A -&gt; Type</tt>, you can make the
--   following <tt> type F' :: A -&gt; Type newtype F' (a :: A) = F'
--   (NoReduce (F a)) deriving stock Generic </tt> It is then true that
--   <tt>forall a. Reduce (F' a) ~ F a</tt>.
type family Reduce (x :: Type) :: Type
newtype NoReduce a
NoReduce :: a -> NoReduce a
reduce :: Coercible a (Reduce a) => a -> Reduce a


-- | This module defines functions, associated type families, and newtypes
--   for use with <a><tt>DerivingVia</tt></a> to allow Plutarch to convert
--   to and from PTypes and Haskell types.
module Plutarch.Lift

-- | Create a Plutarch-level constant, from a Haskell value. Example: &gt;
--   pconstant @PInteger 42
pconstant :: forall p s. PLift p => PLifted p -> Term s p

-- | Like <a>plift'</a> but throws on failure.
plift :: forall p. (HasCallStack, PLift p) => ClosedTerm p -> PLifted p

-- | Convert a Plutarch term to the associated Haskell value. Fail
--   otherwise. This will fully evaluate the arbitrary closed expression,
--   and convert the resulting value.
plift' :: forall p. PUnsafeLiftDecl p => Config -> ClosedTerm p -> Either LiftError (PLifted p)

-- | Error during script evaluation.
data LiftError
LiftError_EvalError :: EvalError -> LiftError
LiftError_KnownTypeError :: BuiltinError -> LiftError
LiftError_FromRepr :: LiftError
LiftError_CompilationError :: Text -> LiftError

-- | Class of Haskell types <tt>h</tt> that can be represented as a Plutus
--   core builtin and converted to a Plutarch type.
--   
--   The Plutarch type is determined by `PConstanted h`. Its Plutus Core
--   representation is given by `PConstantRepr h`.
--   
--   This typeclass is closely tied with <a>PLift</a>.
--   
--   Laws: - <tt>pconstantFromRepr . pconstantToRepr ≡ Just</tt> -
--   <tt>(pconstantToRepr <a>$</a>) . pconstantFromRepr ≡ Just</tt> -
--   <tt>plift . pfromData . flip ptryFrom fst . pconstant .
--   PlutusTx.toData ≡ id</tt> - <tt>PlutusTx.fromData . plift .
--   pforgetData . pdata . pconstant ≡ Just</tt>
--   
--   These laws must be upheld for the sake of soundness of the type
--   system.
class (PUnsafeLiftDecl (PConstanted h), DefaultUni `Includes` PConstantRepr h) => PConstantDecl (h :: Type) where {
    type PConstantRepr h :: Type;
    type PConstanted h :: PType;
}
pconstantToRepr :: PConstantDecl h => h -> PConstantRepr h
pconstantFromRepr :: PConstantDecl h => PConstantRepr h -> Maybe h

-- | Class of Plutarch types <tt>p</tt> that can be converted to/from a
--   Haskell type.
--   
--   The Haskell type is determined by `PLifted p`.
--   
--   This typeclass is closely tied with <a>PConstant</a>.
type PLift = PUnsafeLiftDecl

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaNewtype</tt>.
--   
--   A newtype <tt>Foo a</tt> is considered <a>Constantable</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
type PConstant a = (a ~ PLifted (PConstanted a), PConstantDecl a)

-- | Newtype wrapper for deriving <tt>PConstant</tt> when the wrapped type
--   is directly represented by a builtin UPLC type that is <i>not</i>
--   <tt>Data</tt>.
--   
--   Ex: <tt>PInteger</tt> is directly represented as a builtin integer.
newtype DerivePConstantDirect (h :: Type) (p :: PType)
DerivePConstantDirect :: h -> DerivePConstantDirect (h :: Type) (p :: PType)

-- | Newtype wrapper for deriving <tt>PConstant</tt> when the wrapped type
--   is represented indirectly by a builtin UPLC type that is <i>not</i>
--   <tt>Data</tt>.
--   
--   Ex: <tt>PPubKeyHash</tt> is a newtype to a <tt>PByteString</tt> and
--   <tt>PByteString</tt> is directly represented as a builtin bytestring.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   newtype Foo a = Foo a
--   
--   newtype PFoo a s = PFoo (Term s a)
--   
--   instance forall a. PLift a =&gt; PUnsafeLiftDecl (PFoo a) where
--     type PLifted (PFoo a) = Foo (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaNewtype
--         (Foo a)
--         (PFoo (PConstanted a))
--         (PConstanted a)
--     )
--     instance
--       PConstant a =&gt;
--       PConstantDecl (Foo a)
--   </pre>
newtype DerivePConstantViaNewtype (h :: Type) (p :: PType) (p' :: PType)

-- | The Haskell newtype we are deriving a <tt>PConstant</tt> instance for
DerivePConstantViaNewtype :: h -> DerivePConstantViaNewtype (h :: Type) (p :: PType) (p' :: PType)
newtype DerivePConstantViaBuiltin (h :: Type) (p :: PType) (p' :: PType)
DerivePConstantViaBuiltin :: h -> DerivePConstantViaBuiltin (h :: Type) (p :: PType) (p' :: PType)

-- | Laws: - It must be that <tt>PConstantRepr (PLifted p)</tt> when
--   encoded as a constant in UPLC (via the <a>Constant</a> constructor) is
--   a valid <tt>p</tt>.
class (PConstantDecl (PLifted p), PConstanted (PLifted p) ~ p) => PUnsafeLiftDecl (p :: PType) where {
    type PLifted p = (r :: Type) | r -> p;
}
instance GHC.Classes.Eq Plutarch.Lift.LiftError
instance forall (p :: Plutarch.Internal.PType) (p' :: Plutarch.Internal.PType) h h'. (Plutarch.Lift.PLift p, Plutarch.Lift.PLift p', GHC.Types.Coercible @GHC.Types.Type h h', Plutarch.Lift.ToBuiltin' (Plutarch.Lift.PLifted p') h', Plutarch.Lift.FromBuiltin' h' (Plutarch.Lift.PLifted p')) => Plutarch.Lift.PConstantDecl (Plutarch.Lift.DerivePConstantViaBuiltin h p p')
instance forall arep a. (PlutusTx.Builtins.HasBuiltin.HasFromBuiltin arep, (a :: GHC.Types.Type) GHC.Types.~ (PlutusTx.Builtins.HasBuiltin.FromBuiltin arep :: GHC.Types.Type)) => Plutarch.Lift.FromBuiltin' arep a
instance Plutarch.Lift.FromBuiltin' PlutusTx.Builtins.Internal.BuiltinData PlutusCore.Data.Data
instance forall a arep. (PlutusTx.Builtins.HasBuiltin.HasToBuiltin a, (arep :: GHC.Types.Type) GHC.Types.~ (PlutusTx.Builtins.HasBuiltin.ToBuiltin a :: GHC.Types.Type)) => Plutarch.Lift.ToBuiltin' a arep
instance Plutarch.Lift.ToBuiltin' PlutusCore.Data.Data PlutusTx.Builtins.Internal.BuiltinData
instance forall (p :: Plutarch.Internal.PType) (p' :: Plutarch.Internal.PType) h. (Plutarch.Lift.PLift p, Plutarch.Lift.PLift p', GHC.Types.Coercible @GHC.Types.Type h (Plutarch.Lift.PLifted p')) => Plutarch.Lift.PConstantDecl (Plutarch.Lift.DerivePConstantViaNewtype h p p')
instance forall (p :: Plutarch.Internal.PType) h. (Plutarch.Lift.PLift p, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni h) => Plutarch.Lift.PConstantDecl (Plutarch.Lift.DerivePConstantDirect h p)

module Plutarch.Internal.TypeFamily

-- | Convert a list of `Term s a` to a list of <tt>a</tt>.
type family ToPType as
type family ToPType2 as
type family UnTerm x
type family Snd ab

module Plutarch.Internal.Quantification
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s
data PSome (b :: a -> PType) s
PSome :: Term s (b x) -> PSome (b :: a -> PType) s
newtype PFix f s
PFix :: Term s (f (PFix f)) -> PFix f s

module Plutarch.Internal.Generic

-- | <a>Generic</a> constraint extended to work with Plutarch types.
class (forall s. PGeneric' a s) => PGeneric a
class (Generic (a s), GFrom (a s), GTo (a s), All2 Top (PCode a), All2 Top (GCode (a s)), GDatatypeInfo (a s)) => PGeneric' a s

-- | Like <tt>Code</tt> but for Plutarch types
type PCode a = ToPType2 (GCode (a Any))
gpfrom :: forall a s. PGeneric a => a s -> SOP (Term s) (PCode a)
gpto :: forall a s. PGeneric a => SOP (Term s) (PCode a) -> a s
instance forall (a :: Plutarch.Internal.PType). (forall (s :: Plutarch.Internal.S). Plutarch.Internal.Generic.PGeneric' a s) => Plutarch.Internal.Generic.PGeneric a
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type) (s :: Plutarch.Internal.S). (GHC.Generics.Generic (a s), Generics.SOP.GGP.GFrom (a s), Generics.SOP.GGP.GTo (a s), Data.SOP.Constraint.All2 @{Plutarch.Internal.PType} (Data.SOP.Constraint.Top @{Plutarch.Internal.PType}) (Plutarch.Internal.Generic.PCode a), Data.SOP.Constraint.All2 @{GHC.Types.Type} (Data.SOP.Constraint.Top @{GHC.Types.Type}) (Generics.SOP.GGP.GCode (a s)), Generics.SOP.GGP.GDatatypeInfo (a s)) => Plutarch.Internal.Generic.PGeneric' a s
instance forall a. Generics.SOP.GGP.GTo a => Plutarch.Internal.Generic.GTo' a
instance forall a. Generics.SOP.GGP.GFrom a => Plutarch.Internal.Generic.GFrom' a

module Plutarch.Internal.PlutusType
class PlutusType (a :: PType)
type PlutusTypeStratConstraint strategy :: PType -> Constraint

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType
pcon' :: forall s. PlutusType a => a s -> Term s (PInner a)
pmatch' :: forall s b. PlutusType a => Term s (PInner a) -> (a s -> Term s b) -> Term s b

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a
type PInner a :: PType
class PlutusTypeStrat (strategy :: Type)
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType)
type DPTStrat a :: Type
type DerivedPInner strategy (a :: PType) :: PType
derivedPCon :: forall a s. (PlutusTypeStrat strategy, DerivePlutusType a, DPTStrat a ~ strategy) => a s -> Term s (DerivedPInner strategy a)
derivedPMatch :: forall a s b. (PlutusTypeStrat strategy, DerivePlutusType a, DPTStrat a ~ strategy) => Term s (DerivedPInner strategy a) -> (a s -> Term s b) -> Term s b
class (forall t. PVariant'' t => PVariant'' (a t)) => PVariant a
class (forall t. PCovariant'' t => PCovariant'' (a t)) => PCovariant a
class (forall t. PCovariant'' t => PContravariant'' (a t)) => PContravariant a
type PVariant' a :: Constraint
type PCovariant' a :: Constraint
type PContravariant' a :: Constraint
instance forall (a :: Plutarch.Internal.PType -> Plutarch.Internal.PType). (forall (t :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PVariant'' t => Plutarch.Internal.PlutusType.PVariant'' (a t)) => Plutarch.Internal.PlutusType.PVariant a
instance forall (a :: Plutarch.Internal.PType -> Plutarch.Internal.PType). (forall (t :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PCovariant'' t => Plutarch.Internal.PlutusType.PContravariant'' (a t)) => Plutarch.Internal.PlutusType.PContravariant a
instance forall (a :: Plutarch.Internal.PType -> Plutarch.Internal.PType). (forall (t :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PCovariant'' t => Plutarch.Internal.PlutusType.PCovariant'' (a t)) => Plutarch.Internal.PlutusType.PCovariant a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PCovariant' a => Plutarch.Internal.PlutusType.PCovariant'' a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PContravariant' a => Plutarch.Internal.PlutusType.PContravariant'' a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PVariant' a => Plutarch.Internal.PlutusType.PVariant'' a
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (a Plutarch.Internal.:--> b)
instance forall a (f :: a -> Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PForall @a f)
instance forall a (f :: a -> Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PSome @a f)
instance forall (f :: Plutarch.Internal.PType -> Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PFix f)

module Plutarch.Internal.ScottEncoding
data PlutusTypeScott
newtype PScottEncoded a r s
PScottEncoded :: Term s (ScottFn (ScottList a r) r) -> PScottEncoded a r s
instance forall (a :: Plutarch.Internal.PType). (forall (r :: Plutarch.Internal.PType). Plutarch.Internal.ScottEncoding.SListIScottList a r, Data.SOP.Constraint.SListI2 @{Plutarch.Internal.PType} (Plutarch.Internal.Generic.PCode a), Plutarch.Internal.Generic.PGeneric a) => Plutarch.Internal.ScottEncoding.PlutusTypeScottConstraint a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.Internal.ScottEncoding.PlutusTypeScott
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Data.SOP.Constraint.SListI @{Plutarch.Internal.PType} (Plutarch.Internal.ScottEncoding.ScottList (Plutarch.Internal.Generic.PCode a) r) => Plutarch.Internal.ScottEncoding.SListIScottList a r
instance forall (a :: [[Plutarch.Internal.PType]]) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.ScottEncoding.PScottEncoded a r)

module Plutarch.Internal.Other

-- | Prettyprint a Term via the PLC pretty printer
--   
--   TODO: Heavily improve. It's unreadable right now.
--   
--   We could convert the de Bruijn indices into names with:
--   
--   <pre>
--   show . prettyPlcReadableDef . (\(Right p) -&gt; p) . Scripts.mkTermToEvaluate . compile $ term
--   </pre>
printTerm :: HasCallStack => Config -> ClosedTerm a -> String

-- | Prettyprint a compiled Script via the PLC pretty printer
printScript :: Script -> String

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

-- | An Arbitrary Term with an unknown type
newtype POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Internal.Other.POpaque

module Plutarch.Internal.Newtype
data PlutusTypeNewtype
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Internal.Generic.PGeneric a, (Plutarch.Internal.Generic.PCode a :: [[Plutarch.Internal.PType]]) GHC.Types.~ ((':) @[Plutarch.Internal.PType] ((':) @Plutarch.Internal.PType (Plutarch.Internal.Newtype.GetPNewtype a) ('[] @Plutarch.Internal.PType)) ('[] @[Plutarch.Internal.PType]) :: [[Plutarch.Internal.PType]])) => Plutarch.Internal.Newtype.Helper a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.Internal.Newtype.PlutusTypeNewtype

module Plutarch.Evaluate

-- | Evaluate a script with a big budget, returning the trace log and term
--   result.
evalScript :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a huge budget, returning the trace log and term
--   result.
evalScriptHuge :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a specific budget, returning the trace log and
--   term result.
evalScript' :: ExBudget -> Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])

-- | Evaluate a script without budget limit
--   
--   @since WIP
evalScriptUnlimited :: Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])
type EvalError = (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun)

-- | Compile and evaluate term.
evalTerm :: Config -> ClosedTerm a -> Either Text (Either EvalError (ClosedTerm a), ExBudget, [Text])

-- | Compile and evaluate a ClosedTerm Useful for pre-evaluating terms so
--   that they can be used as constants in an onchain script. Consider the
--   following:
--   _________________________________________________________________________
--   term :: Term _ PInteger term = unsafeEvalTerm NoTracing foo
--   
--   foo :: Term s PInteger foo = (pconstant 1 #+ pconstant 5) #* pconstant
--   3
--   
--   bar :: Term s (PInteger :--&gt; PInteger) bar = plam x -&gt; x + foo
--   
--   bar2 :: Term s (PInteger :--&gt; PInteger) bar2 = plam x -&gt; x +
--   term
--   
--   PI.compile PI.NoTracing bar Right (Script {unScript = Program
--   {_progAnn = (), _progVer = Version {_versionMajor = 1, _versionMinor =
--   0, _versionPatch = 0}, _progTerm = LamAbs () (DeBruijn {dbnIndex = 0})
--   (Apply () (Apply () (Builtin () AddInteger) (Var () (DeBruijn
--   {dbnIndex = 1}))) (Apply () (Apply () (Builtin () MultiplyInteger)
--   (Apply () (Apply () (Builtin () AddInteger) (Constant () (Some
--   (ValueOf DefaultUniInteger 1)))) (Constant () (Some (ValueOf
--   DefaultUniInteger 5))))) (Constant () (Some (ValueOf DefaultUniInteger
--   3)))))}}) PI.compile PI.NoTracing bar2 Right (Script {unScript =
--   Program {_progAnn = (), _progVer = Version {_versionMajor = 1,
--   _versionMinor = 0, _versionPatch = 0}, _progTerm = LamAbs () (DeBruijn
--   {dbnIndex = 0}) (Apply () (Apply () (Builtin () AddInteger) (Var ()
--   (DeBruijn {dbnIndex = 1}))) (Constant () (Some (ValueOf
--   DefaultUniInteger 18))))}})
--   _________________________________________________________________________
--   
--   In bar, foo is an unevaluated term and thus must be evaluated. In
--   bar2, foo has been pre-evaluated with <a>unsafeEvalTerm</a> and thus
--   appears as a constant.
--   
--   Error if the compilation or evaluation fails.
unsafeEvalTerm :: Config -> ClosedTerm a -> ClosedTerm a

-- | Given a compiled <a>Script</a> representing a function that takes
--   arguments, and a list of those <a>Data</a>-encoded arguments, produce
--   a new script with those arguments applied.
applyArguments :: Script -> [Data] -> Script

module Plutarch.Pretty

-- | Prettify a Plutarch term.
--   
--   This will call <a>error</a> if there's a compilation failure. Use
--   <a>prettyTerm'</a> for a non-partial version.
--   
--   <h2>Example ==</h2>
--   
--   <pre>
--   import Plutarch.Prelude
--   import Plutarch.Api.V1
--   
--   checkSignatory :: Term s (PPubKeyHash :--&gt; PScriptContext :--&gt; PUnit)
--   checkSignatory = plam $ ph ctx' -&gt; unTermCont $ do
--     ctx &lt;- pletFieldsC <tt>["txInfo", "purpose"] ctx'
--     purph &lt;- pmatchC ctx.purpose
--     pure $ case purph of
--       PSpending _ -&gt;
--         let signatories = pfield </tt>"signatories" # ctx.txInfo
--         in pif
--             (pelem # pdata ph # pfromData signatories)
--             -- Success!
--             (pconstant ())
--             -- Signature not present.
--             perror
--       _ -&gt; ptraceError "checkSignatoryCont: not a spending tx"
--   </pre>
--   
--   Prettification result:
--   
--   <pre>
--   let frSndPair = !!sndPair
--       unDataSum = (xF -&gt; frSndPair (unConstrData xF))
--       frTailList = !tailList
--       frHeadList = !headList
--       frIfThenElse = !ifThenElse
--   in (oP4ECBT qsrxlF0Y7 -&gt;
--         let cjlB6yrGk = unDataSum qsrxlF0Y7
--             cRFO = unConstrData (frHeadList (frTailList cjlB6yrGk))
--             cs9iR = !!fstPair cRFO
--             w4 = frSndPair cRFO
--         in if equalsInteger 1 cs9iR
--              then if (vModHwqYB -&gt;
--                         let blM6d67 =
--                               (x5sad ePDSInSEC -&gt;
--                                  !(!!chooseList
--                                      ePDSInSEC
--                                      ~False
--                                      ~(if equalsData
--                                             (frHeadList ePDSInSEC)
--                                             vModHwqYB
--                                          then True
--                                          else x5sad (frTailList ePDSInSEC))))
--                             mC = (jfZs -&gt; blM6d67 (itzT -&gt; jfZs jfZs itzT))
--                         in blM6d67 (ispwp_oeT -&gt; mC mC ispwp_oeT))
--                        (bData oP4ECBT)
--                        (unListData
--                           let q6X3 = frHeadList cjlB6yrGk
--                           in frHeadList
--                                let olbZ = unDataSum q6X3
--                                in frTailList
--                                     (frTailList
--                                        (frTailList
--                                           (frTailList
--                                              (frTailList
--                                                 (frTailList
--                                                    (frTailList olbZ)))))))
--                     then ()
--                     else ERROR
--              else !(!trace "checkSignatoryCont: not a spending tx" ~ERROR))
--   </pre>
--   
--   <h2>Semantics ==</h2>
--   
--   <h3>Constants ===</h3>
--   
--   <ul>
--   <li>Builtin integers are printed as regular integers. [0-9]+</li>
--   <li>Builtin bytestrings are printed in hex notation, prefixed by `0x`.
--   0x[0-9a-f]+/i</li>
--   <li>Builtin strings are printed as is.</li>
--   <li>Builtin unit is printed as the unit literal. ()</li>
--   <li>Builtin booleans are printed as the literal <a>True</a> or
--   <a>False</a>.</li>
--   <li>Builtin lists are prettified as list literals, i.e delimited with
--   `[` and `]`.</li>
--   <li>Builtin pairs are prettified as 2-ary tuple literals, e.g. `(a,
--   b)`.</li>
--   <li><tt>I</tt> data (i.e data encoded integers) are prettified like
--   builtin integers with a <tt>#</tt> prefix. #[0-9]+</li>
--   <li><tt>B</tt> data (i.e data encoded bytestrings) are prettified like
--   builtin bytestrings with a <tt>#</tt> prefix. #0x[0-9a-f]+/i</li>
--   <li><tt>List</tt> data (i.e data encoded lists) are prettified like
--   builtin lists with a <tt>#</tt> prefix.</li>
--   <li><tt>Map</tt> data is printed like record literals. Delimited by
--   `{` and `}`.</li>
--   </ul>
--   
--   Each key value pair is prettified like <a>key</a> = <a>value</a> and
--   multiple pairs are joined with `,`.
--   
--   For example, `Map [(I 42, I 0), (I 100, I 1)]` is prettified as `{ #42
--   = #0, #100 = #1 }` - Constr data has two core elements in its
--   prettified form:
--   
--   <ul>
--   <li>The constructor index, prettified as an integer prefixed with
--   <tt>Σ</tt> (sigma).</li>
--   <li>Its fields, prettified as a list.</li>
--   </ul>
--   
--   These two elements are then joined with a <a>.</a> (period).
--   
--   For example, `Constr 1 [I 42]` is prettified as "Σ1.[#42]".
--   
--   <h3>Builtin functions ===</h3>
--   
--   Builtin functions are prettified into their name, in title case.
--   
--   <h3>Forced term ===</h3>
--   
--   Forced terms are prefixed with a <tt>!</tt>. The unary operator
--   <tt>!</tt> has higher fixity than function application.
--   
--   <h3>Delayed term ===</h3>
--   
--   Delayed terms are prefixed with a <a>~</a>. The unary operator
--   <a>~</a> has higher fixity than function application.
--   
--   <h3>Var ===</h3>
--   
--   Random names are generated for all variable bindings, and these names
--   are used to refer to them.
--   
--   Names are always unique, between 1 and 8 characters in length, and
--   begin with a lowercase letter.
--   
--   Names may consist of alphanumeric characters, underscore, or single
--   quotes.
--   
--   <h3>LamAbs ===</h3>
--   
--   Lambdas are prettified similar to haskell lambdas, i.e `x -&gt; ...`.
--   
--   Lambdas with multiple arguments are detected and simplified: `x y z
--   -&gt; ...`.
--   
--   <h3>Apply ===</h3>
--   
--   Application is, simply, a space - just like haskell. `f x`.
--   
--   Multi arg applications to the same function are detected and
--   simplified: `f x y`.
--   
--   <h3>Error term ===</h3>
--   
--   <tt>perror</tt> is represented by the literal <tt>ERROR</tt>.
--   
--   <h3>Special handling ===</h3>
--   
--   To achieve better prettification, certain AST structures are given
--   special handling logic.
--   
--   <ul>
--   <li>The AST structure produced by <tt>plet</tt> (Single <a>Apply</a> +
--   <a>LamAbs</a> pair) is prettified into Haskell-like let bindings.</li>
--   <li>Lazy if<i>then</i>else (<tt>pif</tt> in particular, not
--   <tt>pif'</tt>) is detected and prettified into Haskell-like syntax:
--   `if cond then expr1 else expr2`.</li>
--   </ul>
--   
--   Chains of if<i>then</i>else are nested:
--   
--   <pre>
--   if cond
--     then expr1
--     else if cond
--       then expr2
--       else expr3
--   
--   </pre>
--   
--   <ul>
--   <li>When generating names for bindings, well known structures are
--   identified and given special names.</li>
--   </ul>
--   
--   This machinery is made to be extensible in the future.
--   
--   For example, the structure of the <tt>pfix</tt> function is well known
--   and constant - so it is simply called <tt>fix</tt> in the output.
--   
--   Bindings to forced builtin functions inherit the builtin function
--   name, prefixed with a <tt>fr</tt>.
prettyTerm :: Config -> ClosedTerm a -> Doc ()

-- | Same as <a>prettyTerm</a> but also includes the execution budget and
--   script size
--   
--   @since WIP
prettyTermAndCost :: forall a. Config -> ClosedTerm a -> Doc ()

-- | Non-partial <a>prettyTerm</a>.
prettyTerm' :: Config -> ClosedTerm p -> Either Text (Doc ())

-- | <a>prettyTerm</a> for pre-compiled <a>Script</a>s.
prettyScript :: Script -> Doc ()

module Plutarch.TryFrom

-- | <tt>PTryFrom a b</tt> represents a subtyping relationship between
--   <tt>a</tt> and <tt>b</tt>, and a way to go from <tt>a</tt> to
--   <tt>b</tt>. Laws: - <tt>(punsafeCoerce . fst) <a>$</a> tcont (ptryFrom
--   x) ≡ pure x</tt>
class PSubtype a b => PTryFrom (a :: PType) (b :: PType) where {
    type PTryFromExcess a b :: PType;
    type PTryFromExcess a b = PTryFromExcess a (PInner b);
}
ptryFrom' :: forall s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom' :: forall s r. (PTryFrom a b, PTryFrom a (PInner b), PTryFromExcess a b ~ PTryFromExcess a (PInner b)) => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom :: forall b a s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
data PSubtypeRelation
PSubtypeRelation :: PSubtypeRelation
PNoSubtypeRelation :: PSubtypeRelation
type family PSubtype (a :: PType) (b :: PType) :: Constraint
type family PSubtype' (a :: PType) (b :: PType) :: PSubtypeRelation
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a
pupcastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PCovariant p) => Proxy p -> Term s (p b) -> Term s (p a)
pdowncastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PContravariant p) => Proxy p -> Term s (p a) -> Term s (p b)

module Plutarch.Unsafe
punsafeBuiltin :: DefaultFun -> Term s a

-- | Unsafely coerce the type-tag of a Term.
--   
--   This should mostly be avoided, though it can be safely used to assert
--   known types of Datums, Redeemers or ScriptContext.
punsafeCoerce :: Term s a -> Term s b

-- | <i>Deprecated: Use <tt>pconstant</tt> instead.</i>
punsafeConstant :: Some (ValueOf DefaultUni) -> Term s a

-- | Unsafely coerce from the <a>PInner</a> representation of a Term,
--   assuming that the value is a safe construction of the Term.
punsafeDowncast :: Term s (PInner a) -> Term s a

module Plutarch.Num
class PNum (a :: PType)
(#+) :: PNum a => Term s a -> Term s a -> Term s a
(#+) :: (PNum a, PNum (PInner a)) => Term s a -> Term s a -> Term s a
(#-) :: PNum a => Term s a -> Term s a -> Term s a
(#-) :: (PNum a, PNum (PInner a)) => Term s a -> Term s a -> Term s a
(#*) :: PNum a => Term s a -> Term s a -> Term s a
(#*) :: (PNum a, PNum (PInner a)) => Term s a -> Term s a -> Term s a
pnegate :: PNum a => Term s (a :--> a)
pnegate :: (PNum a, PNum (PInner a)) => Term s (a :--> a)
pabs :: PNum a => Term s (a :--> a)
pabs :: (PNum a, PNum (PInner a)) => Term s (a :--> a)
psignum :: PNum a => Term s (a :--> a)
psignum :: (PNum a, PNum (PInner a)) => Term s (a :--> a)
pfromInteger :: PNum a => Integer -> Term s a
pfromInteger :: (PNum a, PNum (PInner a)) => Integer -> Term s a
infix 6 #+
infix 6 #-
infix 6 #*
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Plutarch.Num.PNum a => GHC.Num.Num (Plutarch.Internal.Term s a)

module Plutarch.Internal.Trace

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Trace the given message at the debug level before evaluating the given
--   argument.
ptraceDebug :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a
ptrace' :: Term s (PString :--> (a :--> a))

-- | Backward compatibility synonym for <a>ptraceInfo</a>.

-- | <i>Deprecated: Use ptraceInfo</i>
ptrace :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

module Plutarch.Internal.PLam
plam :: forall c. (PLamN a b s, HasCallStack) => (Term s c -> a) -> Term s (c :--> b)
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b
instance forall a' (s :: Plutarch.Internal.S) (a :: Plutarch.Internal.PType). ((a' :: GHC.Types.Type) GHC.Types.~ (Plutarch.Internal.Term s a :: GHC.Types.Type)) => Plutarch.Internal.PLam.PLamN a' a s
instance forall a' (s :: Plutarch.Internal.S) (a :: Plutarch.Internal.PType) b' (b :: Plutarch.Internal.PType). ((a' :: GHC.Types.Type) GHC.Types.~ (Plutarch.Internal.Term s a :: GHC.Types.Type), Plutarch.Internal.PLam.PLamN b' b s) => Plutarch.Internal.PLam.PLamN (a' -> b') (a Plutarch.Internal.:--> b) s

module Plutarch.Bool

-- | Plutus <tt>BuiltinBool</tt>
data PBool (s :: S)
PTrue :: PBool (s :: S)
PFalse :: PBool (s :: S)
class PEq t
(#==) :: PEq t => Term s t -> Term s t -> Term s PBool
(#==) :: (PEq t, PGeneric t, PlutusType t, All2 PEq (PCode t)) => Term s t -> Term s t -> Term s PBool
infix 4 #==

-- | Partial ordering relation.
--   
--   <h1>Laws</h1>
--   
--   <a>#&lt;=</a> must form a partial order. More precisely:
--   
--   <ol>
--   <li><tt>x #&lt;= x</tt> <tt>=</tt> <tt>True</tt> (<tt>#&lt;=</tt> is
--   reflexive)</li>
--   <li><tt>(x #&lt;= y) #&amp;&amp; (y #&lt;= x)</tt> <tt>=</tt> <tt>x
--   #== y</tt> (<tt>#&lt;=</tt> is anti-symmetric)</li>
--   <li><tt>(x #&lt;= y) #&amp;&amp; (y #&lt;= z)</tt> <tt>=</tt> <tt>x
--   #&lt;= z</tt> (@#&lt;= is transitive)</li>
--   </ol>
--   
--   Furthermore, <a>#&lt;</a> must be an equivalent strict partial order
--   to <a>#&lt;=</a>:
--   
--   <ol>
--   <li><tt>x #&lt;= y</tt> <tt>=</tt> <tt>(x #&lt; y) #|| (x #==
--   y)</tt></li>
--   <li><tt>x #&lt; x</tt> <tt>=</tt> <tt>False</tt> (<tt>#&lt;</tt> is
--   irreflexive)</li>
--   <li><tt>x #&lt; y</tt> <tt>=</tt> <tt>pnot (y #&lt; x)</tt>
--   (<tt>#&lt;</tt> is asymmetric)</li>
--   <li><tt>(x #&lt; y) #&amp;&amp; (y #&lt; z)</tt> <tt>=</tt> <tt>x
--   #&lt; z</tt> (<tt>#&lt;</tt> is transitive)</li>
--   </ol>
--   
--   Lastly, if you define <a>#&gt;=</a> or <a>#&gt;</a>, ensure that the
--   following also hold:
--   
--   <ol>
--   <li><tt>x #&gt; y</tt> <tt>=</tt> <tt>y #&lt; x</tt></li>
--   <li><tt>x #&gt;= y</tt> <tt>=</tt> <tt>pnot (x #&lt; y)</tt></li>
--   </ol>
--   
--   The default implementations of <a>#&gt;=</a> and <a>#&gt;</a> ensure
--   these laws.
class PEq t => PPartialOrd t
(#<=) :: PPartialOrd t => Term s t -> Term s t -> Term s PBool
(#<=) :: (PPartialOrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool
(#<) :: PPartialOrd t => Term s t -> Term s t -> Term s PBool
(#<) :: (PPartialOrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool

-- | @since WIP
(#>=) :: forall (s :: S). PPartialOrd t => Term s t -> Term s t -> Term s PBool

-- | @since WIP
(#>) :: forall (s :: S). PPartialOrd t => Term s t -> Term s t -> Term s PBool
infix 4 #<=
infix 4 #<
infix 4 #>=
infix 4 #>

-- | Total ordering relation.
--   
--   <h1>Laws</h1>
--   
--   <a>pmax</a> and <a>pmin</a> must form a commutative semiring without
--   identity elements, where addition also distributes over
--   multiplication. More precisely:
--   
--   <ol>
--   <li><tt>pmax x y</tt> <tt>=</tt> <tt>pmax y x</tt> (<tt>pmax</tt> is
--   commutative)</li>
--   <li><tt>pmin x y</tt> <tt>=</tt> <tt>pmin y x</tt> (<tt>pmin</tt> is
--   commutative)</li>
--   <li><tt>pmax x (pmax y z)</tt> <tt>=</tt> <tt>pmax (pmax x y) z</tt>
--   (<tt>pmax</tt> is associative)</li>
--   <li><tt>pmin x (pmin y z)</tt> <tt>=</tt> <tt>pmin (pmin x y) z</tt>
--   (<tt>pmin</tt> is associative)</li>
--   <li><tt>pmax x (pmin y z)</tt> <tt>=</tt> <tt>pmin (pmax x y) (pmax x
--   z)</tt> (<tt>pmax</tt> distributes over <tt>pmin</tt>)</li>
--   <li><tt>pmin x (pmax y z)</tt> <tt>=</tt> <tt>pmax (pmin x y) (pmin x
--   z)</tt> (<tt>pmin</tt> distributes over <tt>pmax</tt>)</li>
--   </ol>
--   
--   Furthermore, the following must hold relative <a>#&lt;</a>:
--   
--   <ol>
--   <li><tt>pmin x y</tt> <tt>=</tt> <tt>if (x #&lt; y) then x else
--   y</tt></li>
--   <li><tt>pmax x y</tt> <tt>=</tt> <tt>if (x #&lt; y) then y else
--   x</tt></li>
--   </ol>
--   
--   Laws 7 and 8 are also the defaults, as for most types, this is the
--   best you can do.
class PPartialOrd t => POrd t

-- | @since WIP
pmax :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t

-- | @since WIP
pmin :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t

-- | Lazy if-then-else.
pif :: Term s PBool -> Term s a -> Term s a -> Term s a

-- | Strict version of <a>pif</a>. Emits slightly less code.
pif' :: Term s (PBool :--> (a :--> (a :--> a)))

-- | Boolean negation for <a>PBool</a> terms.
pnot :: Term s (PBool :--> PBool)

-- | Lazily evaluated boolean and for <a>PBool</a> terms.
(#&&) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 3 #&&

-- | Lazily evaluated boolean or for <a>PBool</a> terms.
(#||) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 2 #||

-- | Hoisted, Plutarch level, lazily evaluated boolean or function.
por :: Term s (PBool :--> (PDelayed PBool :--> PDelayed PBool))

-- | Hoisted, Plutarch level, lazily evaluated boolean and function.
pand :: Term s (PBool :--> (PDelayed PBool :--> PDelayed PBool))

-- | Hoisted, Plutarch level, strictly evaluated boolean and function.
pand' :: Term s (PBool :--> (PBool :--> PBool))

-- | Hoisted, Plutarch level, strictly evaluated boolean or function.
por' :: Term s (PBool :--> (PBool :--> PBool))

-- | Scott-encoded bool.
data PSBool (s :: S)
PSTrue :: PSBool (s :: S)
PSFalse :: PSBool (s :: S)

-- | Strict version of <a>pmatch</a> for <a>PSBool</a>.
pmatchStrict :: forall (r :: PType) (s :: S). Term s PSBool -> (PSBool s -> Term s r) -> Term s r
pstrue :: forall (s :: S). Term s PSBool
psfalse :: forall (s :: S). Term s PSBool

-- | Lazy <tt>if</tt> on Scott-encoded bool.
psif :: forall (s :: S) (a :: PType). Term s PSBool -> Term s a -> Term s a -> Term s a

-- | Strict <tt>if</tt> on Scott-encoded bool.
psif' :: forall (s :: S) (a :: PType). Term s PSBool -> Term s a -> Term s a -> Term s a

-- | <tt>not</tt> on Scott-encoded bool.
psnot :: forall (s :: S). Term s PSBool -> Term s PSBool
psand :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool
psand' :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool
psor :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool
psor' :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool
instance forall (s :: Plutarch.Internal.S). GHC.Show.Show (Plutarch.Bool.PBool s)
instance forall (s :: Plutarch.Internal.S). GHC.Show.Show (Plutarch.Bool.PSBool s)
instance forall (s :: Plutarch.Internal.S). GHC.Classes.Ord (Plutarch.Bool.PSBool s)
instance forall (s :: Plutarch.Internal.S). GHC.Classes.Eq (Plutarch.Bool.PSBool s)
instance Plutarch.Lift.PConstantDecl GHC.Types.Bool
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Bool.PSBool
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Bool.PSBoolRaw a)
instance Plutarch.Bool.PPartialOrd Plutarch.Bool.PBool
instance Plutarch.Bool.POrd Plutarch.Bool.PBool
instance Plutarch.Bool.PEq Plutarch.Bool.PBool
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Bool.PBool
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Bool.PBool

module Plutarch.Integer

-- | Plutus BuiltinInteger
data PInteger s
class PIntegral a
pdiv :: PIntegral a => Term s (a :--> (a :--> a))
pdiv :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pmod :: PIntegral a => Term s (a :--> (a :--> a))
pmod :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pquot :: PIntegral a => Term s (a :--> (a :--> a))
pquot :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
prem :: PIntegral a => Term s (a :--> (a :--> a))
prem :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))

-- | Performs modulo exponentiation. More precisely, <tt>pexpModInteger b e
--   m</tt> performs <tt>b</tt> to the power of <tt>e</tt>, modulo
--   <tt>m</tt>. The result is always non-negative.
--   
--   <h1>Note</h1>
--   
--   This will error if the modulus is zero. When given a negative
--   exponent, this will try to find a modular multiplicative inverse, and
--   will error if none exists.
--   
--   @since WIP
pexpModInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> (PInteger :--> PInteger)))
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Integer.PInteger
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Integer.PInteger s)
instance Plutarch.Lift.PConstantDecl GHC.Num.Integer.Integer
instance Plutarch.Integer.PIntegral Plutarch.Integer.PInteger
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Integer.PInteger
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Integer.PInteger
instance Plutarch.Bool.PEq Plutarch.Integer.PInteger
instance Plutarch.Bool.PPartialOrd Plutarch.Integer.PInteger
instance Plutarch.Bool.POrd Plutarch.Integer.PInteger
instance Plutarch.Num.PNum Plutarch.Integer.PInteger

module Plutarch.ByteString

-- | A Plutarch-level representation of bytes.
--   
--   <h1>Note =</h1>
--   
--   This type is intentionally quite restrictive, as it's not really meant
--   to be computed with. Instead, it ensures certain operations' type
--   safety while also allowing more sensible signatures. If you want to do
--   anything with <a>PByte</a>s, we recommend converting them to
--   <a>PInteger</a>s first.
--   
--   @since WIP
data PByte (s :: S)

-- | Plutus <tt>BuiltinByteString</tt>
data PByteString s

-- | Type designating whether logical operations should use padding or
--   truncation semantics. See <a>CIP-122</a> for more details on this.
--   
--   @since WIP
data PLogicOpSemantics (s :: S)

-- | Indicates that padding semantics should be used.
--   
--   @since WIP
ppadding :: forall (s :: S). Term s PLogicOpSemantics

-- | Indicates that truncation semantics should be used.
--   
--   @since WIP
ptruncation :: forall (s :: S). Term s PLogicOpSemantics

-- | Construct a <a>PByteString</a> of the specified length (0 if negative)
--   consisting entirely of zero bytes.
--   
--   @since WIP
pzeroesBS :: forall (s :: S). Term s (PInteger :--> PByteString)

-- | Construct a <a>PByteString</a> of the specified length (0 if negative)
--   consisting entirely of ones; that is, where every byte is
--   <tt>0xFF</tt>.
--   
--   @since WIP
ponesBS :: forall (s :: S). Term s (PInteger :--> PByteString)

-- | Given a desired length and a <a>PByte</a>, construct a
--   <a>PByteString</a> of the specified length (0 if negative) consisting
--   entirely of that <a>PByte</a>.
--   
--   @since WIP
preplicateBS :: forall (s :: S). Term s (PInteger :--> (PByte :--> PByteString))

-- | Verify that the given predicate holds for every byte in the argument.
--   
--   @since WIP
pallBS :: forall (s :: S). Term s ((PByte :--> PBool) :--> (PByteString :--> PBool))

-- | Perform the logical AND of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
pandBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical OR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
porBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical XOR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
pxorBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical complement of a <a>PByteString</a>, as per
--   <a>CIP-122</a>.
--   
--   @since WIP
pcomplementBS :: forall (s :: S). Term s (PByteString :--> PByteString)

-- | Prepend a <a>PByte</a> to a 'PByteString.
--   
--   @since WIP
pconsBS :: Term s (PByte :--> (PByteString :--> PByteString))

-- | Slice a <a>PByteString</a> with given start index and slice length.
--   
--   <pre>
--   &gt;&gt;&gt; (pslice # 2 # 3 phexByteStr "4102afde5b2a") #== phexByteStr "afde5b"
--   </pre>
psliceBS :: Term s (PInteger :--> (PInteger :--> (PByteString :--> PByteString)))

-- | Find the length of a <a>PByteString</a>.
plengthBS :: Term s (PByteString :--> PInteger)

-- | Given a valid index into a <a>PByteString</a>, returns the
--   <a>PByte</a> at that index. Will crash if given an out-of-bounds
--   index.
--   
--   @since WIP
pindexBS :: Term s (PByteString :--> (PInteger :--> PByte))

-- | Convert a <a>PByte</a> into its corresponding <a>PInteger</a>.
--   
--   @since WIP
pbyteToInteger :: Term s (PByte :--> PInteger)

-- | Try to convert a <a>PInteger</a> into its corresponding <a>PByte</a>.
--   This operation is checked, and will error if given a negative
--   <a>PInteger</a>, or one too large to fit into a byte.
--   
--   @since WIP
pintegerToByte :: Term s (PInteger :--> PByte)

-- | As <a>pintegerToByte</a>, but unchecked. Be <i>very</i> careful with
--   this: it can potentially break downstream invariants and wreak all
--   manner of hard-to-discover havoc. Only included for reasons of
--   efficiency.
--   
--   @since WIP
punsafeIntegerToByte :: Term s (PInteger :--> PByte)

-- | Interpret a hex string as a PByteString.
phexByteStr :: HasCallStack => String -> Term s PByteString
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.ByteString.PByteString
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.ByteString.PByteString s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.ByteString.PByte
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.ByteString.PByte s)
instance Plutarch.Bool.POrd Plutarch.ByteString.PLogicOpSemantics
instance Plutarch.Bool.PPartialOrd Plutarch.ByteString.PLogicOpSemantics
instance Plutarch.Bool.PEq Plutarch.ByteString.PLogicOpSemantics
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.ByteString.PLogicOpSemantics
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.ByteString.PLogicOpSemantics s)
instance Plutarch.Lift.PConstantDecl Data.ByteString.Internal.Type.ByteString
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.ByteString.PLogicOpSemantics
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.ByteString.PByte
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.ByteString.PByte
instance Plutarch.Lift.PConstantDecl GHC.Word.Word8
instance Plutarch.Bool.PEq Plutarch.ByteString.PByte
instance Plutarch.Bool.PPartialOrd Plutarch.ByteString.PByte
instance Plutarch.Bool.POrd Plutarch.ByteString.PByte
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.ByteString.PByteString
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.ByteString.PByteString
instance Plutarch.Bool.PEq Plutarch.ByteString.PByteString
instance Plutarch.Bool.PPartialOrd Plutarch.ByteString.PByteString
instance Plutarch.Bool.POrd Plutarch.ByteString.PByteString
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s Plutarch.ByteString.PByteString)
instance forall (s :: Plutarch.Internal.S). GHC.Base.Monoid (Plutarch.Internal.Term s Plutarch.ByteString.PByteString)

module Plutarch.String

-- | Plutus <tt>BuiltinString</tt> values
data PString s

-- | Verify if the given argument is the ASCII encoding of a hex digit.
--   This includes specifically the following ASCII ranges (inclusively):
--   
--   <ul>
--   <li>48-54 (digits 0 through 9)</li>
--   <li>65-70 (upper-case A through upper-case F)</li>
--   <li>97-102 (lower-case a through lower-case f)</li>
--   </ul>
--   
--   @since WIP
pisHexDigit :: forall (s :: S). Term s (PInteger :--> PBool)

-- | Create a PString from <a>Text</a>

-- | <i>Deprecated: Use <a>pconstant</a> instead.</i>
pfromText :: Text -> Term s PString

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.String.PString
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.String.PString s)
instance Plutarch.Lift.PConstantDecl Data.Text.Internal.Text
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.String.PString
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.String.PString
instance forall (s :: Plutarch.Internal.S). Data.String.IsString (Plutarch.Internal.Term s Plutarch.String.PString)
instance Plutarch.Bool.PEq Plutarch.String.PString
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s Plutarch.String.PString)
instance forall (s :: Plutarch.Internal.S). GHC.Base.Monoid (Plutarch.Internal.Term s Plutarch.String.PString)

module Plutarch.Show
class PShow t

-- | Return the string representation of a Plutarch value
--   
--   If the wrap argument is True, optionally wrap the output in `(..)` if
--   it represents multiple parameters.
pshow' :: PShow t => Bool -> Term s t -> Term s PString

-- | Return the string representation of a Plutarch value
--   
--   If the wrap argument is True, optionally wrap the output in `(..)` if
--   it represents multiple parameters.
pshow' :: (PShow t, PGeneric t, PlutusType t, All2 PShow (PCode t)) => Bool -> Term s t -> Term s PString

-- | Return the string representation of a Plutarch value
pshow :: PShow a => Term s a -> Term s PString

-- | Causes an error where the input is shown in the message. Works for all
--   types.
pshowAndErr :: Term s a -> Term s b
instance Plutarch.Show.PShow Plutarch.String.PString
instance Plutarch.Show.PShow Plutarch.Bool.PBool
instance Plutarch.Show.PShow Plutarch.Integer.PInteger
instance Plutarch.Show.PShow Plutarch.ByteString.PByteString

module Plutarch.Trace

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the info
--   level.
ptraceInfoShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Trace the given message at the info level, then terminate with
--   <a>perror</a>.
ptraceInfoError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Trace the given message at the info level if the argument is true.
ptraceInfoIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the info level if the argument is false.
ptraceInfoIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level before evaluating the given
--   argument.
ptraceDebug :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the debug
--   level.
ptraceDebugShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Trace the given message at the debug level if the argument is true.
ptraceDebugIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level if the argument is false.
ptraceDebugIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level, then terminate with
--   <a>perror</a>.
ptraceDebugError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Backward compatibility synonym for <a>ptraceInfo</a>.

-- | <i>Deprecated: Use ptraceInfo</i>
ptrace :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Synonym for <a>ptraceInfoShowId</a>.

-- | <i>Deprecated: Use ptraceInfoShowId</i>
ptraceShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Synonym for <a>ptraceInfoError</a>.

-- | <i>Deprecated: Use ptraceInfoError</i>
ptraceError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Synonym for <a>ptraceInfoIfTrue</a>.

-- | <i>Deprecated: Use ptraceInfoIfTrue</i>
ptraceIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Synonym for <a>ptraceInfoIfFalse</a>.

-- | <i>Deprecated: Use ptraceInfoIfFalse</i>
ptraceIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

module Plutarch.Internal.TermCont
hashOpenTerm :: Term s a -> TermCont s Dig
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
($sel:runTermCont:TermCont) :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Base.Functor (Plutarch.Internal.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Base.Applicative (Plutarch.Internal.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Base.Monad (Plutarch.Internal.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Control.Monad.Fail.MonadFail (Plutarch.Internal.TermCont.TermCont @r s)

module Plutarch
data (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a

-- | Compile a (closed) Plutus Term to a usable script
compile :: Config -> ClosedTerm a -> Either Text Script
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
type Dig = Digest Blake2b_160
hashTerm :: Config -> ClosedTerm a -> Either Text Dig

-- | Lambda Application.
papp :: Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)
data PDelayed (a :: PType) (s :: S)

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Let bindings.
--   
--   This is approximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b
pthrow :: HasCallStack => Text -> Term s a
data Term (s :: S) (a :: PType)
data S

-- | Shorthand for Plutarch types.
type PType = S -> Type

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #
class PlutusType (a :: PType)
type PInner a :: PType

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType

-- | Prettify a Plutarch term.
--   
--   This will call <a>error</a> if there's a compilation failure. Use
--   <a>prettyTerm'</a> for a non-partial version.
--   
--   <h2>Example ==</h2>
--   
--   <pre>
--   import Plutarch.Prelude
--   import Plutarch.Api.V1
--   
--   checkSignatory :: Term s (PPubKeyHash :--&gt; PScriptContext :--&gt; PUnit)
--   checkSignatory = plam $ ph ctx' -&gt; unTermCont $ do
--     ctx &lt;- pletFieldsC <tt>["txInfo", "purpose"] ctx'
--     purph &lt;- pmatchC ctx.purpose
--     pure $ case purph of
--       PSpending _ -&gt;
--         let signatories = pfield </tt>"signatories" # ctx.txInfo
--         in pif
--             (pelem # pdata ph # pfromData signatories)
--             -- Success!
--             (pconstant ())
--             -- Signature not present.
--             perror
--       _ -&gt; ptraceError "checkSignatoryCont: not a spending tx"
--   </pre>
--   
--   Prettification result:
--   
--   <pre>
--   let frSndPair = !!sndPair
--       unDataSum = (xF -&gt; frSndPair (unConstrData xF))
--       frTailList = !tailList
--       frHeadList = !headList
--       frIfThenElse = !ifThenElse
--   in (oP4ECBT qsrxlF0Y7 -&gt;
--         let cjlB6yrGk = unDataSum qsrxlF0Y7
--             cRFO = unConstrData (frHeadList (frTailList cjlB6yrGk))
--             cs9iR = !!fstPair cRFO
--             w4 = frSndPair cRFO
--         in if equalsInteger 1 cs9iR
--              then if (vModHwqYB -&gt;
--                         let blM6d67 =
--                               (x5sad ePDSInSEC -&gt;
--                                  !(!!chooseList
--                                      ePDSInSEC
--                                      ~False
--                                      ~(if equalsData
--                                             (frHeadList ePDSInSEC)
--                                             vModHwqYB
--                                          then True
--                                          else x5sad (frTailList ePDSInSEC))))
--                             mC = (jfZs -&gt; blM6d67 (itzT -&gt; jfZs jfZs itzT))
--                         in blM6d67 (ispwp_oeT -&gt; mC mC ispwp_oeT))
--                        (bData oP4ECBT)
--                        (unListData
--                           let q6X3 = frHeadList cjlB6yrGk
--                           in frHeadList
--                                let olbZ = unDataSum q6X3
--                                in frTailList
--                                     (frTailList
--                                        (frTailList
--                                           (frTailList
--                                              (frTailList
--                                                 (frTailList
--                                                    (frTailList olbZ)))))))
--                     then ()
--                     else ERROR
--              else !(!trace "checkSignatoryCont: not a spending tx" ~ERROR))
--   </pre>
--   
--   <h2>Semantics ==</h2>
--   
--   <h3>Constants ===</h3>
--   
--   <ul>
--   <li>Builtin integers are printed as regular integers. [0-9]+</li>
--   <li>Builtin bytestrings are printed in hex notation, prefixed by `0x`.
--   0x[0-9a-f]+/i</li>
--   <li>Builtin strings are printed as is.</li>
--   <li>Builtin unit is printed as the unit literal. ()</li>
--   <li>Builtin booleans are printed as the literal <a>True</a> or
--   <a>False</a>.</li>
--   <li>Builtin lists are prettified as list literals, i.e delimited with
--   `[` and `]`.</li>
--   <li>Builtin pairs are prettified as 2-ary tuple literals, e.g. `(a,
--   b)`.</li>
--   <li><tt>I</tt> data (i.e data encoded integers) are prettified like
--   builtin integers with a <tt>#</tt> prefix. #[0-9]+</li>
--   <li><tt>B</tt> data (i.e data encoded bytestrings) are prettified like
--   builtin bytestrings with a <tt>#</tt> prefix. #0x[0-9a-f]+/i</li>
--   <li><tt>List</tt> data (i.e data encoded lists) are prettified like
--   builtin lists with a <tt>#</tt> prefix.</li>
--   <li><tt>Map</tt> data is printed like record literals. Delimited by
--   `{` and `}`.</li>
--   </ul>
--   
--   Each key value pair is prettified like <a>key</a> = <a>value</a> and
--   multiple pairs are joined with `,`.
--   
--   For example, `Map [(I 42, I 0), (I 100, I 1)]` is prettified as `{ #42
--   = #0, #100 = #1 }` - Constr data has two core elements in its
--   prettified form:
--   
--   <ul>
--   <li>The constructor index, prettified as an integer prefixed with
--   <tt>Σ</tt> (sigma).</li>
--   <li>Its fields, prettified as a list.</li>
--   </ul>
--   
--   These two elements are then joined with a <a>.</a> (period).
--   
--   For example, `Constr 1 [I 42]` is prettified as "Σ1.[#42]".
--   
--   <h3>Builtin functions ===</h3>
--   
--   Builtin functions are prettified into their name, in title case.
--   
--   <h3>Forced term ===</h3>
--   
--   Forced terms are prefixed with a <tt>!</tt>. The unary operator
--   <tt>!</tt> has higher fixity than function application.
--   
--   <h3>Delayed term ===</h3>
--   
--   Delayed terms are prefixed with a <a>~</a>. The unary operator
--   <a>~</a> has higher fixity than function application.
--   
--   <h3>Var ===</h3>
--   
--   Random names are generated for all variable bindings, and these names
--   are used to refer to them.
--   
--   Names are always unique, between 1 and 8 characters in length, and
--   begin with a lowercase letter.
--   
--   Names may consist of alphanumeric characters, underscore, or single
--   quotes.
--   
--   <h3>LamAbs ===</h3>
--   
--   Lambdas are prettified similar to haskell lambdas, i.e `x -&gt; ...`.
--   
--   Lambdas with multiple arguments are detected and simplified: `x y z
--   -&gt; ...`.
--   
--   <h3>Apply ===</h3>
--   
--   Application is, simply, a space - just like haskell. `f x`.
--   
--   Multi arg applications to the same function are detected and
--   simplified: `f x y`.
--   
--   <h3>Error term ===</h3>
--   
--   <tt>perror</tt> is represented by the literal <tt>ERROR</tt>.
--   
--   <h3>Special handling ===</h3>
--   
--   To achieve better prettification, certain AST structures are given
--   special handling logic.
--   
--   <ul>
--   <li>The AST structure produced by <tt>plet</tt> (Single <a>Apply</a> +
--   <a>LamAbs</a> pair) is prettified into Haskell-like let bindings.</li>
--   <li>Lazy if<i>then</i>else (<tt>pif</tt> in particular, not
--   <tt>pif'</tt>) is detected and prettified into Haskell-like syntax:
--   `if cond then expr1 else expr2`.</li>
--   </ul>
--   
--   Chains of if<i>then</i>else are nested:
--   
--   <pre>
--   if cond
--     then expr1
--     else if cond
--       then expr2
--       else expr3
--   
--   </pre>
--   
--   <ul>
--   <li>When generating names for bindings, well known structures are
--   identified and given special names.</li>
--   </ul>
--   
--   This machinery is made to be extensible in the future.
--   
--   For example, the structure of the <tt>pfix</tt> function is well known
--   and constant - so it is simply called <tt>fix</tt> in the output.
--   
--   Bindings to forced builtin functions inherit the builtin function
--   name, prefixed with a <tt>fr</tt>.
prettyTerm :: Config -> ClosedTerm a -> Doc ()

-- | <a>prettyTerm</a> for pre-compiled <a>Script</a>s.
prettyScript :: Script -> Doc ()

-- | Prettyprint a Term via the PLC pretty printer
--   
--   TODO: Heavily improve. It's unreadable right now.
--   
--   We could convert the de Bruijn indices into names with:
--   
--   <pre>
--   show . prettyPlcReadableDef . (\(Right p) -&gt; p) . Scripts.mkTermToEvaluate . compile $ term
--   </pre>
printTerm :: HasCallStack => Config -> ClosedTerm a -> String

-- | Prettyprint a compiled Script via the PLC pretty printer
printScript :: Script -> String
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

-- | An Arbitrary Term with an unknown type
newtype POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque
plam :: forall c. (PLamN a b s, HasCallStack) => (Term s c -> a) -> Term s (c :--> b)
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
hashOpenTerm :: Term s a -> TermCont s Dig
($sel:runTermCont:TermCont) :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Configuration for Plutarch scripts at compile time. This indicates
--   whether we want to trace, and if so, under what log level and mode.
data Config

-- | Pattern for a tracing config, with both its log level and mode.
pattern Tracing :: LogLevel -> TracingMode -> Config

-- | Pattern for the config that does no tracing (also the default).
pattern NoTracing :: Config

-- | How to trace.
data TracingMode
DetTracing :: TracingMode
DoTracing :: TracingMode
DoTracingAndBinds :: TracingMode

-- | What logging level we want to use.
data LogLevel
LogInfo :: LogLevel
LogDebug :: LogLevel

-- | If the config indicates that we want to trace, get its mode.
tracingMode :: Config -> Maybe TracingMode

-- | If the config indicates that we want to trace, get its log level.
logLevel :: Config -> Maybe LogLevel
pgetConfig :: (Config -> Term s a) -> Term s a
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s
data PSome (b :: a -> PType) s
PSome :: Term s (b x) -> PSome (b :: a -> PType) s
newtype PScottEncoded a r s
PScottEncoded :: Term s (ScottFn (ScottList a r) r) -> PScottEncoded a r s
data PlutusTypeScott
data PlutusTypeNewtype
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType)
type DPTStrat a :: Type
class (forall t. PCovariant'' t => PCovariant'' (a t)) => PCovariant a
type PCovariant' a :: Constraint
class (forall t. PCovariant'' t => PContravariant'' (a t)) => PContravariant a
type PContravariant' a :: Constraint
class (forall t. PVariant'' t => PVariant'' (a t)) => PVariant a
type PVariant' a :: Constraint

module Plutarch.Unit
data PUnit s
PUnit :: PUnit s
instance Plutarch.Lift.PConstantDecl ()
instance Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Bool.PEq (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Bool.PPartialOrd (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Bool.POrd (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Unit.PUnit @{Plutarch.Internal.S}))
instance forall (s :: Plutarch.Internal.S). GHC.Base.Monoid (Plutarch.Internal.Term s (Plutarch.Unit.PUnit @{Plutarch.Internal.S}))
instance Plutarch.Show.PShow (Plutarch.Unit.PUnit @{Plutarch.Internal.S})

module Plutarch.Pair

-- | Plutus encoding of Pairs.
--   
--   Note: This is represented differently than <tt>BuiltinPair</tt>. It is
--   scott-encoded.
data PPair (a :: PType) (b :: PType) (s :: S)
PPair :: Term s a -> Term s b -> PPair (a :: PType) (b :: PType) (s :: S)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Show.PShow b) => Plutarch.Show.PShow (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Bool.PEq a, Plutarch.Bool.PEq b) => Plutarch.Bool.PEq (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Pair.PPair a b s)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Pair.PPair a b)

module Plutarch.Maybe

-- | Plutus Maybe type, with Scott-encoded repr
data PMaybe (a :: S -> Type) (s :: S)
PJust :: Term s a -> PMaybe (a :: S -> Type) (s :: S)
PNothing :: PMaybe (a :: S -> Type) (s :: S)

-- | Construct a <a>PJust</a> value.
--   
--   @since WIP
pjust :: forall (a :: S -> Type) (s :: S). Term s (a :--> PMaybe a)

-- | Construct a <a>PNothing</a> value.
--   
--   @since WIP
pnothing :: forall (a :: S -> Type) (s :: S). Term s (PMaybe a)

-- | Yields true if the given <a>PMaybe</a> value is of form
--   <tt><a>PJust</a> _</tt>.
--   
--   @since WIP
pisJust :: forall (a :: S -> Type) (s :: S). Term s (PMaybe a :--> PBool)

-- | Extracts the element out of a <a>PJust</a> and throws an error if its
--   argument is <a>PNothing</a>.
pfromJust :: forall (a :: S -> Type) (s :: S). Term s (PMaybe a :--> a)

-- | Extracts the element out of a <a>PJust</a> and throws a custom error
--   if it's given a <a>PNothing</a>.
--   
--   @since WIP
ptraceIfNothing :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s (PMaybe a) -> Term s a

-- | Extract a <a>PMaybe</a> by providing a default value in case of
--   <a>PJust</a>.
--   
--   @since WIP
pfromMaybe :: forall (a :: S -> Type) (s :: S). Term s (a :--> (PMaybe a :--> a))

-- | Given a default value, a function and a <a>PMaybe</a> value, yields
--   the default value if the <a>PMaybe</a> value is <a>PNothing</a> and
--   applies the function to the value stored in the <a>PJust</a>
--   otherwise.
--   
--   @since WIP
pmaybe :: forall (b :: S -> Type) (a :: S -> Type) (s :: S). Term s (b :--> ((a :--> b) :--> (PMaybe a :--> b)))

-- | Extract the value stored in a <a>PMaybe</a> container. If there's no
--   value, throw an error with the given message.
--   
--   @since WIP
passertPJust :: forall (a :: S -> Type) (s :: S). Term s (PString :--> (PMaybe a :--> a))

-- | Map underlying value if <a>PMaybe</a> is <a>PJust</a>, do nothing if
--   it is <a>PNothing</a>
--   
--   @since WIP
pmapMaybe :: Term s ((a :--> b) :--> (PMaybe a :--> PMaybe b))
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Maybe.PMaybe a s)
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Maybe.PMaybe a)


-- | Scott-encoded lists and ListLike typeclass
module Plutarch.List
data PList (a :: PType) (s :: S)
PSCons :: Term s a -> Term s (PList a) -> PList (a :: PType) (s :: S)
PSNil :: PList (a :: PType) (s :: S)

-- | Plutarch types that behave like lists.
class PListLike (list :: PType -> PType) where {
    type PElemConstraint list (a :: PType) :: Constraint;
}

-- | Canonical eliminator for list-likes.
pelimList :: (PListLike list, PElemConstraint list a) => (Term s a -> Term s (list a) -> Term s r) -> Term s r -> Term s (list a) -> Term s r

-- | Cons an element onto an existing list.
pcons :: (PListLike list, PElemConstraint list a) => Term s (a :--> (list a :--> list a))

-- | The empty list
pnil :: (PListLike list, PElemConstraint list a) => Term s (list a)

-- | Return the first element of a list. Partial, throws an error upon
--   encountering an empty list.
phead :: (PListLike list, PElemConstraint list a) => Term s (list a :--> a)

-- | Take the tail of a list, meaning drop its head. Partial, throws an
--   error upon encountering an empty list.
ptail :: (PListLike list, PElemConstraint list a) => Term s (list a :--> list a)

-- | <i> O(1) </i>. Check if a list is empty
pnull :: (PListLike list, PElemConstraint list a) => Term s (list a :--> PBool)

-- | 'PIsListLike list a' constraints <tt>list</tt> be a <a>PListLike</a>
--   with valid element type, <tt>a</tt>.
type PIsListLike list a = (PListLike list, PElemConstraint list a)

-- | <i> O(n) </i>. Convert from any ListLike to any ListLike, provided
--   both lists' element constraints are met.
pconvertLists :: forall f g a s. (PIsListLike f a, PIsListLike g a) => Term s (f a :--> g a)
pshowList :: forall list a s. (PShow a, PIsListLike list a) => Term s (list a :--> PString)

-- | <i> O(min(n, m)) </i>. Check if two lists are equal.
plistEquals :: (PIsListLike list a, PEq a) => Term s (list a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check if element is in the list
pelem :: (PIsListLike list a, PEq a) => Term s (a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Count the number of elements in the list
plength :: PIsListLike list a => Term s (list a :--> PInteger)

-- | Index a BuiltinList, throwing an error if the index is out of bounds.
ptryIndex :: PIsListLike list a => Natural -> Term s (list a) -> Term s a

-- | Drop the first n fields of a List.
--   
--   The term will be statically generated as repeated applications of
--   <a>ptail</a>, which will be more efficient in many circumstances.
pdrop :: PIsListLike list a => Natural -> Term s (list a) -> Term s (list a)

-- | <i> O(n) </i>. like haskell level <tt>find</tt> but on plutarch level
pfind :: PIsListLike l a => Term s ((a :--> PBool) :--> (l a :--> PMaybe a))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the Plutarch
--   level, not infix and with arguments reversed, errors if the specified
--   index is greater than or equal to the lists length
pelemAt :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the plutarch
--   level
(#!!) :: PIsListLike l a => Term s (l a) -> Term s PInteger -> Term s a

-- | <i> O(1) </i>. Create a singleton list from an element
psingleton :: PIsListLike list a => Term s (a :--> list a)

-- | Extract head and tail of the list, if list is not empty.
puncons :: PIsListLike list a => Term s (list a :--> PMaybe (PPair a (list a)))

-- | Extract head and tail of the list, throws error if list is empty.
ptryUncons :: PIsListLike list a => Term s (list a :--> PPair a (list a))

-- | <i> O(n) </i>. Concatenate two lists
--   
--   Example: &gt; pconcat # psingleton x # psingleton y == plistLiteral
--   [x, y]
--   
--   pconcat exhibits identities with empty lists such that &gt; forall x.
--   pconcat # pnil # x == x &gt; forall x. pconcat # x # pnil == x
pconcat :: PIsListLike list a => Term s (list a :--> (list a :--> list a))

-- | <i> O(min(n, m)) </i>. Zip two lists together with a passed function.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzipWith :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => Term s ((a :--> (b :--> c)) :--> (list a :--> (list b :--> list c)))

-- | Like <a>pzipWith</a> but with Haskell-level merge function.
pzipWith' :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => (Term s a -> Term s b -> Term s c) -> Term s (list a :--> (list b :--> list c))

-- | <i> O(min(n, m)) </i>. Zip two lists together, creating pairs of the
--   elements.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzip :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list (PPair a b)) => Term s (list a :--> (list b :--> list (PPair a b)))

-- | <i> O(n) </i>. Map a function over a list of elements
pmap :: (PListLike list, PElemConstraint list a, PElemConstraint list b) => Term s ((a :--> b) :--> (list a :--> list b))

-- | <i> O(n) </i>. Filter elements from a list that don't match the
--   predicate.
pfilter :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> list a))

-- | Like <a>pelimList</a>, but with a fixpoint recursion hatch.
precList :: PIsListLike list a => (Term s (list a :--> r) -> Term s a -> Term s (list a) -> Term s r) -> (Term s (list a :--> r) -> Term s r) -> Term s (list a :--> r)

-- | <i> O(n) </i>. Fold on a list right-associatively.
pfoldr :: PIsListLike list a => Term s ((a :--> (b :--> b)) :--> (b :--> (list a :--> b)))

-- | The same as <a>pfoldr'</a>, but with Haskell-level reduction function.
pfoldr' :: PIsListLike list a => (forall s. Term s a -> Term s b -> Term s b) -> Term s (b :--> (list a :--> b))

-- | <i> O(n) </i>. Fold on a list right-associatively, with opportunity
--   for short circuting.
--   
--   May short circuit when given reducer function is lazy in its second
--   argument.
pfoldrLazy :: PIsListLike list a => Term s ((a :--> (PDelayed b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list left-associatively.
pfoldl :: PIsListLike list a => Term s ((b :--> (a :--> b)) :--> (b :--> (list a :--> b)))

-- | The same as <a>pfoldl</a>, but with Haskell-level reduction function.
pfoldl' :: PIsListLike list a => (forall s. Term s b -> Term s a -> Term s b) -> Term s (b :--> (list a :--> b))

-- | <i> O(n) </i>. Check that predicate holds for all elements in a list.
pall :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check that predicate holds for any element in a list.
pany :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Reverse a list-like structure.
--   
--   @since WIP
preverse :: forall (l :: (S -> Type) -> S -> Type) (a :: S -> Type) (s :: S). PIsListLike l a => Term s (l a :--> l a)

-- | <i> O(n) </i>. Checks if a list-list structure is sorted.
--   
--   @since WIP
pcheckSorted :: forall (l :: (S -> Type) -> S -> Type) (a :: S -> Type) (s :: S). (PIsListLike l a, POrd a) => Term s (l a :--> PBool)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.List.PList a s)
instance Plutarch.List.PListLike Plutarch.List.PList
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.List.PList a)

module Plutarch.Crypto

-- | Hash a <a>PByteString</a> using SHA-256.
psha2_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using SHA3-256.
psha3_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Blake2B-224.
pblake2b_224 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Blake2B-256.
pblake2b_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Keccak-256.
pkeccak_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Ripemd_160.
pripemd_160 :: Term s (PByteString :--> PByteString)

-- | Verify the signature against the public key and message.

-- | <i>Deprecated: use one of the Ed25519, Schnorr- or ECDSA Secp256k1
--   signature verification functions</i>
pverifySignature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify an ED25519 signature arguments are in this order: pubkey,
--   message, signature
pverifyEd25519Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify an ECDSA SECP256k1 signature arguments are in this order:
--   pubkey, message, signature
pverifyEcdsaSecp256k1Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify a Schnorr SECP256k1 signature arguments are in this order:
--   pubkey, message, signature
pverifySchnorrSecp256k1Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

module Plutarch.Builtin
data PData (s :: S)
pfstBuiltin :: Term s (PBuiltinPair a b :--> a)
psndBuiltin :: Term s (PBuiltinPair a b :--> b)
pasConstr :: Term s (PData :--> PBuiltinPair PInteger (PBuiltinList PData))
pasMap :: Term s (PData :--> PBuiltinList (PBuiltinPair PData PData))
pasList :: Term s (PData :--> PBuiltinList PData)
pasInt :: Term s (PData :--> PInteger)
plistData :: Term s (PBuiltinList PData :--> PData)

-- | Create a Plutarch-level <a>PAsData</a> constant, from a Haskell value.
--   Example: &gt; pconstantData @PInteger 42
pconstantData :: forall p h s. (ToData h, PLifted p ~ h, PConstanted h ~ p) => h -> Term s (PAsData p)
pconstrBuiltin :: Term s (PInteger :--> (PBuiltinList PData :--> PAsData (PBuiltinPair PInteger (PBuiltinList PData))))
pasByteStr :: Term s (PData :--> PByteString)

-- | Plutus <tt>BuiltinPair</tt>
data PBuiltinPair (a :: PType) (b :: PType) (s :: S)

-- | Plutus <tt>BuiltinList</tt>
data PBuiltinList (a :: PType) (s :: S)
PCons :: Term s a -> Term s (PBuiltinList a) -> PBuiltinList (a :: PType) (s :: S)
PNil :: PBuiltinList (a :: PType) (s :: S)

-- | <i>Deprecated: Use <a>pconstant</a> instead.</i>
pdataLiteral :: Data -> Term s PData

-- | Laws: - If <tt>PSubtype PData a</tt>, then <tt>pdataImpl a</tt> must
--   be <a>pupcast</a>. - pdataImpl . pupcast . pfromDataImpl ≡ id -
--   pfromDataImpl . punsafeDowncast . pdataImpl ≡ id
class PIsData a
pfromDataImpl :: PIsData a => Term s (PAsData a) -> Term s a
pfromDataImpl :: (PIsData a, PIsData (PInner a)) => Term s (PAsData a) -> Term s a
pdataImpl :: PIsData a => Term s a -> Term s PData
pdataImpl :: (PIsData a, PIsData (PInner a)) => Term s a -> Term s PData
pdata :: PIsData a => Term s a -> Term s (PAsData a)
pfromData :: PIsData a => Term s (PAsData a) -> Term s a
data PAsData (a :: PType) (s :: S)
pforgetData :: forall s a. Term s (PAsData a) -> Term s PData

-- | Inverse of <a>pforgetData'</a>.
prememberData :: forall (p :: PType -> PType) s. PVariant p => Proxy p -> Term s (p PData) -> Term s (p (PAsData PData))

-- | Like <a>prememberData</a> but generalised.
prememberData' :: forall a (p :: PType -> PType) s. (PSubtype PData a, PVariant p) => Proxy p -> Term s (p a) -> Term s (p (PAsData a))

-- | Serialise any builtin data to its cbor represented by a builtin
--   bytestring
pserialiseData :: Term s (PData :--> PByteString)

-- | Construct a builtin pair of <a>PData</a> elements.
--   
--   Uses <a>PAsData</a> to preserve more information about the underlying
--   <a>PData</a>.
ppairDataBuiltin :: Term s (PAsData a :--> (PAsData b :--> PBuiltinPair (PAsData a) (PAsData b)))
pchooseListBuiltin :: Term s (PBuiltinList a :--> (b :--> (b :--> b)))
pchooseData :: Term s (PData :--> (a :--> (a :--> (a :--> (a :--> (a :--> a))))))

newtype PDataNewtype (a :: PType) (s :: S)
PDataNewtype :: Term s (PAsData a) -> PDataNewtype (a :: PType) (s :: S)
instance forall k (f :: k -> Plutarch.Internal.PType) (a :: k). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Helper2 @{k} f a)
instance forall k (f :: k -> Plutarch.Internal.PType) (a :: k) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Builtin.Helper2 @{k} f a s)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Helper3 @{k2} @{k1} f b a)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Builtin.Helper3 @{k2} @{k1} f b a s)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Helper4 @{k2} @{k1} f b a)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Builtin.Helper4 @{k2} @{k1} f b a s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Builtin.Flip @{k2} @{k1} f a b)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Builtin.PDataNewtype a s)
instance Plutarch.Lift.PConstantDecl PlutusCore.Data.Data
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Bool.PPartialOrd a) => Plutarch.Bool.PPartialOrd (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Bool.PPartialOrd a) => Plutarch.Bool.POrd (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData a)) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PDataNewtype a))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Integer.PInteger)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.ByteString.PByteString)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData))
instance forall (a :: Plutarch.Internal.PType). (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData a), Plutarch.Builtin.PIsData a) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PBuiltinList (Plutarch.Builtin.PAsData a)))
instance forall (a :: Plutarch.Internal.PType) (a' :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType) (b' :: Plutarch.Internal.PType). (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a, (a :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.Builtin.PAsData a' :: Plutarch.Internal.PType), Plutarch.Builtin.PIsData a', Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData b, (b :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.Builtin.PAsData b' :: Plutarch.Internal.PType), Plutarch.Builtin.PIsData b') => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PBuiltinPair a b))
instance forall k1 k2 (f :: k1 -> k2 -> Plutarch.Internal.PType) (b :: k2) (a :: k1). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Builtin.Helper4 @{k1} @{k2} f b a)
instance Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinPair Plutarch.Builtin.PData Plutarch.Builtin.PData)
instance forall k1 k2 (f :: k1 -> k2 -> Plutarch.Internal.PType) (b :: k2) (a :: k1). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Builtin.Helper3 @{k1} @{k2} f b a)
instance forall k (f :: k -> Plutarch.Internal.PType) (a :: k). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Builtin.Helper2 @{k} f a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinList a) => Plutarch.Builtin.Fc 'GHC.Types.True a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData a => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PAsData a)
instance Plutarch.Builtin.PIsData Plutarch.Builtin.PData
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PSubtype Plutarch.Builtin.PData a => Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinList a)
instance Plutarch.Builtin.PIsData Plutarch.Integer.PInteger
instance Plutarch.Builtin.PIsData Plutarch.ByteString.PByteString
instance Plutarch.Builtin.PIsData Plutarch.Bool.PBool
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinPair (Plutarch.Builtin.PAsData a) (Plutarch.Builtin.PAsData b))
instance Plutarch.Builtin.PIsData (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinPair Plutarch.Integer.PInteger (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData))
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.Builtin.PAsData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PConstantDecl (Plutarch.Builtin.PAsDataLifted a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Builtin.PAsData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.Fc (Plutarch.Builtin.F a) a => Plutarch.Bool.PEq (Plutarch.Builtin.PBuiltinList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Builtin.PAsData a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Builtin.PData)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Bool.PBool)
instance Plutarch.Show.PShow Plutarch.Builtin.PData
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.PData
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Builtin.PData
instance Plutarch.Bool.PEq Plutarch.Builtin.PData
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.Builtin.PData
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Lift.PLift a, Plutarch.Bool.PEq a) => Plutarch.Builtin.Fc 'GHC.Types.False a
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Lift.PLift a) => Plutarch.Show.PShow (Plutarch.Builtin.PBuiltinList a)
instance forall a. Plutarch.Lift.PConstant a => Plutarch.Lift.PConstantDecl [a]
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PUnsafeLiftDecl a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Builtin.PBuiltinList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PLift a => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PBuiltinList a)
instance Plutarch.List.PListLike Plutarch.Builtin.PBuiltinList
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PBuiltinPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Lift.PLift a, Plutarch.Lift.PLift b) => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Builtin.PBuiltinPair a b)
instance forall a b. (Plutarch.Lift.PConstant a, Plutarch.Lift.PConstant b) => Plutarch.Lift.PConstantDecl (a, b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Show.PShow b) => Plutarch.Show.PShow (Plutarch.Builtin.PBuiltinPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Bool.PEq a, Plutarch.Bool.PEq b) => Plutarch.Bool.PEq (Plutarch.Builtin.PBuiltinPair a b)

module Plutarch.FFI

-- | Equality of inner types - Plutarch on the left and Haskell on the
--   right.
type family (p :: PType) >~< (t :: Type) :: Constraint

-- | Plutarch type of lists compatible with the PlutusTx encoding of
--   Haskell lists and convertible with the regular <a>PList</a> using
--   <a>plistToTx</a> and <a>plistFromTx</a>.
data PTxList (a :: PType) (s :: S)
PTxCons :: Term s a -> Term s (PTxList a) -> PTxList (a :: PType) (s :: S)
PTxNil :: PTxList (a :: PType) (s :: S)

-- | Plutarch type compatible with the PlutusTx encoding of Haskell
--   <a>Maybe</a> and convertible with the regular <a>PMaybe</a> using
--   <a>pmaybeToTx</a> and <a>pmaybeFromTx</a>.
data PTxMaybe (a :: PType) (s :: S)
PTxJust :: Term s a -> PTxMaybe (a :: PType) (s :: S)
PTxNothing :: PTxMaybe (a :: PType) (s :: S)

-- | Compile and export a Plutarch term so it can be used by
--   <a>applyCode</a>.
foreignExport :: forall p t. p >~< t => Config -> ClosedTerm p -> CompiledCode t

-- | Import compiled UPLC code (such as a spliced <a>compile</a> result) as
--   a Plutarch term.
foreignImport :: forall p t. p >~< t => CompiledCode t -> ClosedTerm p

-- | Export Plutarch term of any type as <tt>CompiledCode Void</tt>.
opaqueExport :: Config -> ClosedTerm p -> CompiledCode Void

-- | Import compiled UPLC code of any type as a Plutarch opaque term.
opaqueImport :: CompiledCode t -> ClosedTerm POpaque

-- | Convert a <a>PTxList</a> to a <a>PList</a>, probably after importing
--   it with <a>foreignImport</a>.
plistFromTx :: Term s (PTxList a :--> PList a)

-- | Convert a <a>PList</a> to a <a>PTxList</a>, perhaps before exporting
--   it with <a>foreignExport</a>.
plistToTx :: Term s (PList a :--> PTxList a)

-- | Convert a <a>PTxMaybe</a> to a <a>PMaybe</a>, probably after importing
--   it with <a>foreignImport</a>.
pmaybeFromTx :: Term s (PTxMaybe a :--> PMaybe a)

-- | Convert a <a>PMaybe</a> to a <a>PTxMaybe</a>, perhaps before exporting
--   it with <a>foreignExport</a>.
pmaybeToTx :: Term s (PMaybe a :--> PTxMaybe a)

-- | Seriously unsafe, may fail at run time or result in unexpected
--   behaviour in your on-chain validator.
unsafeForeignExport :: Config -> ClosedTerm p -> CompiledCode t

-- | Seriously unsafe, may fail at run time or result in unexpected
--   behaviour in your on-chain validator.
unsafeForeignImport :: CompiledCode t -> ClosedTerm p
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.FFI.PTxList a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.HasDatatypeInfo (Plutarch.FFI.PTxList a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Plutarch.FFI.PTxList a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxList a s)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.FFI.PTxMaybe a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.FFI.PTxMaybe a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.HasDatatypeInfo (Plutarch.FFI.PTxMaybe a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Plutarch.FFI.PTxMaybe a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxMaybe a s)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxList' a r)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxList' a r s)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxMaybe' a r)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxMaybe' a r s)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.FFI.PTxMaybe' a r)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxMaybe a)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.FFI.PTxList' a r)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.FFI.PTxList a)
instance Plutarch.List.PListLike Plutarch.FFI.PTxList

module Plutarch.DataRepr.Internal.FromData

-- | removes the PAsData if the hole requires it but leaves it there if it
--   doesn't
--   
--   <pre>
--   &gt;&gt;&gt; :t pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) PInteger)
--   pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) PInteger)
--   :: forall (s :: S). Term s (PInteger @{S})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) (PAsData PInteger))
--   pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) (PAsData PInteger))
--   :: forall (s :: S). Term s (PAsData (PInteger @{S}))
--   </pre>
class PFromDataable (a :: PType) (b :: PType) | b -> a, a -> b
pmaybeFromAsData :: PFromDataable a b => Term s (PAsData a) -> Term s b
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.FromData.PFromDataable a (Plutarch.Builtin.PAsData a)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, (b :: Plutarch.Internal.PType) GHC.Types.~ (a :: Plutarch.Internal.PType)) => Plutarch.DataRepr.Internal.FromData.PFromDataable a b

module Plutarch.DataRepr.Internal.HList
data HRec as
[HNil] :: HRec '[]
[HCons] :: Labeled name a -> HRec as -> HRec ('(name, a) ': as)
newtype HRecGeneric as
HRecGeneric :: HRec as -> HRecGeneric as
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[$sel:unLabeled:Labeled] :: Labeled sym a -> a

-- | Index a <a>HRec</a> with a field in a provided list of data fields.
--   Implicitly unwraps `PAsData a` to <tt>a</tt> when necessary.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>

-- | <i>Deprecated: please use getField from GHC.Records</i>
hrecField :: forall name c as a b s. (ElemOf name a as, Term s (PAsData b) ~ a, PFromDataable b c) => HRec as -> Term s c

-- | Index a HList with a field in a provided list of fields.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>
hrecField' :: forall name a as. ElemOf name a as => HRec as -> a

-- | Indexing type-level lists
type family IndexList (n :: Nat) (l :: [k]) :: k

-- | Indexing list of labeled pairs by label
type family IndexLabel name as

-- | Return the single item from a singleton list
type family SingleItem (as :: [k]) :: k

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

-- | GADT proof-witness of HList membership, usable as an index
data Elem (a :: k) (as :: [k])
[Here] :: Elem a (a ': as)
[There] :: Elem a as -> Elem a (b ': as)

-- | Construct an <a>Elem</a> via Nat.
--   
--   This class could instead be a more direct version of
--   <tt>indexHList</tt>, but perhaps the <a>Elem</a> encoding will be
--   useful.
class IndexLabel name as ~ a => ElemOf name a as | as name -> a

-- | Construct the <a>Elem</a> corresponding to a Nat index.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; natElem @_ @0
--   Here
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; natElem @_ @3
--   There (There (There Here))
--   </pre>
elemOf :: ElemOf name a as => Elem '(name, a) as
instance forall (name :: GHC.Types.Symbol) a (as :: [(GHC.Types.Symbol, GHC.Types.Type)]). ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name as :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as) => GHC.Records.HasField @{GHC.Types.Symbol} name (Plutarch.DataRepr.Internal.HList.HRecGeneric as) a
instance forall (name :: GHC.Types.Symbol) a (as :: [(GHC.Types.Symbol, GHC.Types.Type)]). Plutarch.DataRepr.Internal.HList.ElemOf name a ((':) @(GHC.Types.Symbol, GHC.Types.Type) '(name, a) as)
instance forall (name :: GHC.Types.Symbol) (b :: (GHC.Types.Symbol, GHC.Types.Type)) (as :: [(GHC.Types.Symbol, GHC.Types.Type)]) a. ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name ((':) @(GHC.Types.Symbol, GHC.Types.Type) b as) :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as) => Plutarch.DataRepr.Internal.HList.ElemOf name a ((':) @(GHC.Types.Symbol, GHC.Types.Type) b as)
instance forall (name :: GHC.Types.Symbol) (c :: Plutarch.Internal.PType) (as :: [(GHC.Types.Symbol, GHC.Types.Type)]) a (b :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name as :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as, (Plutarch.Internal.Term s (Plutarch.Builtin.PAsData b) :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.FromData.PFromDataable b c) => GHC.Records.HasField @{GHC.Types.Symbol} name (Plutarch.DataRepr.Internal.HList.HRec as) (Plutarch.Internal.Term s c)

module Plutarch.DataRepr.Internal

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
newtype PDataSum defs s
PDataSum :: NS (Compose (Term s) PDataRecord) defs -> PDataSum defs s

-- | If there is only a single variant, then we can safely extract it.
punDataSum :: Term s (PDataSum '[def] :--> PDataRecord def)

-- | Try getting the nth variant. Errs if it's another variant.
ptryIndexDataSum :: KnownNat n => Proxy n -> Term s (PDataSum (def ': defs) :--> PDataRecord (IndexList n (def ': defs)))

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label ':= a) ': l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])
data DataReprHandlers (out :: PType) (defs :: [[PLabeledType]]) (s :: S)
[DRHNil] :: DataReprHandlers out '[] s
[DRHCons] :: (Term s (PDataRecord def) -> Term s out) -> DataReprHandlers out defs s -> DataReprHandlers out (def ': defs) s

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaData</tt>.
--   
--   A type <tt>Foo a</tt> is considered <a>ConstantableData</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   <li>The newtype has <tt>FromData</tt> and <tt>ToData</tt>
--   instances</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   data Bar a = Bar a deriving stock (GHC.Generic)
--   
--   PlutusTx.makeLift ''Bar
--   PlutusTx.makeIsDataIndexed ''Bar [('Bar, 0)]
--   
--   data PBar (a :: PType) (s :: S)
--     = PBar (Term s (PDataRecord '["_0" ':= a]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (SOP.Generic, PIsDataRepr)
--     deriving (PlutusType, PIsData, PDataFields) via PIsDataReprInstances (PBar a)
--   
--   instance
--     forall a.
--     PLiftData a =&gt;
--     PUnsafeLiftDecl (PBar a)
--     where
--     type PLifted (PBar a) = Bar (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaData
--         (Bar a)
--         (PBar (PConstanted a))
--     )
--     instance
--       PConstantData a =&gt;
--       PConstantDecl (Bar a)
--   </pre>
type PConstantData h = (PConstant h, FromData h, ToData h, PIsData (PConstanted h))

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)
[PDCons] :: forall name_x x xs s. PUnLabel name_x ~ x => Term s (PAsData x) -> Term s (PDataRecord xs) -> PDataRecord (name_x ': xs) s
[PDNil] :: PDataRecord '[] s
type PLiftData p = (PLift p, FromData (PLifted p), ToData (PLifted p), PIsData p)
data PLabeledType
(:=) :: Symbol -> PType -> PLabeledType
type family PLabelIndex (name :: Symbol) (as :: [PLabeledType]) :: Nat
type family PUnLabel (a :: PLabeledType) :: PType
type family PLookupLabel name as

-- | Safely index a <a>PDataRecord</a>.
pindexDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord as) -> Term s (PAsData (PUnLabel (IndexList n as)))

-- | Safely drop the first n items of a <a>PDataRecord</a>.
pdropDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord xs) -> Term s (PDataRecord (Drop n xs))

-- | For deriving <tt>PConstant</tt> for a wrapped type represented by a
--   builtin type, see <tt>DerivePConstantViaNewtype</tt>.
newtype DerivePConstantViaData (h :: Type) (p :: PType)

-- | The Haskell type for which @PConstant is being derived.
DerivePConstantViaData :: h -> DerivePConstantViaData (h :: Type) (p :: PType)
newtype DualReprHandler s out def
DualRepr :: (Term s (PDataRecord def) -> Term s (PDataRecord def) -> Term s out) -> DualReprHandler s out def
data PlutusTypeData
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataRecordShowHelper as)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.PDataRecordShowHelper as s)
instance forall (as :: [(GHC.Types.Symbol, Plutarch.Internal.PType)]) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.HRecP as s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.DataRepr.Internal.Flip @{k2} @{k1} f a b)
instance forall (b :: Plutarch.TryFrom.PSubtypeRelation) (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.ExcessForField b a s)
instance forall k (a :: k -> GHC.Types.Type) (b :: k -> GHC.Types.Type) (s :: k). GHC.Generics.Generic (Plutarch.DataRepr.Internal.Helper @{k} a b s)
instance forall (n :: GHC.TypeNats.Nat) (x :: [Plutarch.DataRepr.Internal.PLabeledType]) (xs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). (Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord x), Plutarch.DataRepr.Internal.SumValidation (n GHC.TypeNats.+ 1) xs, GHC.TypeNats.KnownNat n) => Plutarch.DataRepr.Internal.SumValidation n ((':) @[Plutarch.DataRepr.Internal.PLabeledType] x xs)
instance forall (n :: GHC.TypeNats.Nat). Plutarch.DataRepr.Internal.SumValidation n ('[] @[Plutarch.DataRepr.Internal.PLabeledType])
instance forall (ys :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.DataRepr.Internal.SumValidation 0 ys => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.DataRepr.Internal.PDataSum ys)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (ase :: [(GHC.Types.Symbol, Plutarch.Internal.PType)]). (Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as), (Plutarch.TryFrom.PTryFromExcess (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as) :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.DataRepr.Internal.HRecP ase :: Plutarch.Internal.PType)) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.DataRepr.Internal.PDataRecord as))
instance forall (pty :: Plutarch.Internal.PType) (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (ase :: [(GHC.Types.Symbol, Plutarch.Internal.PType)]) (name :: GHC.Types.Symbol). (Plutarch.DataRepr.Internal.Helper2 (Plutarch.TryFrom.PSubtype' Plutarch.Builtin.PData pty) pty, Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as), (Plutarch.TryFrom.PTryFromExcess (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as) :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.DataRepr.Internal.HRecP ase :: Plutarch.Internal.PType)) => Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (name 'Plutarch.DataRepr.Internal.:= pty) as))
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData a) => Plutarch.DataRepr.Internal.Helper2 'Plutarch.TryFrom.PNoSubtypeRelation a
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.DataRepr.Internal.Helper2 'Plutarch.TryFrom.PSubtypeRelation a
instance Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (p :: Plutarch.Internal.PType) h. (Plutarch.TryFrom.PSubtype Plutarch.Builtin.PData p, Plutarch.Lift.PLift p, PlutusTx.IsData.Class.FromData h, PlutusTx.IsData.Class.ToData h) => Plutarch.Lift.PConstantDecl (Plutarch.DataRepr.Internal.DerivePConstantViaData h p)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.DataRepr.Internal.IsPDataSum (Plutarch.Internal.Generic.PCode a), Data.SOP.Constraint.SListI @{[Plutarch.DataRepr.Internal.PLabeledType]} (Plutarch.DataRepr.Internal.IsPDataSumDefs (Plutarch.Internal.Generic.PCode a)), Plutarch.Internal.Generic.PGeneric a) => Plutarch.DataRepr.Internal.PlutusTypeDataConstraint a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.DataRepr.Internal.PlutusTypeData
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Data.SOP.Constraint.SListI @{[Plutarch.DataRepr.Internal.PLabeledType]} defs => Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataSum defs)
instance Plutarch.DataRepr.Internal.IsPDataSum ('[] @[Plutarch.Internal.PType])
instance forall (xs :: [[Plutarch.Internal.PType]]) (l :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.IsPDataSum xs => Plutarch.DataRepr.Internal.IsPDataSum ((':) @[Plutarch.Internal.S -> GHC.Types.Type] ((':) @(Plutarch.Internal.S -> GHC.Types.Type) (Plutarch.DataRepr.Internal.PDataRecord l) ('[] @(Plutarch.Internal.S -> GHC.Types.Type))) xs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). (Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Top @{[Plutarch.DataRepr.Internal.PLabeledType]}) defs, Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Compose @{Plutarch.Internal.PType} @{[Plutarch.DataRepr.Internal.PLabeledType]} Plutarch.Show.PShow Plutarch.DataRepr.Internal.PDataRecord) defs) => Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.Builtin.PIsData (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.Bool.PEq (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Compose @{Plutarch.Internal.PType} @{[Plutarch.DataRepr.Internal.PLabeledType]} Plutarch.Bool.POrd Plutarch.DataRepr.Internal.PDataRecord) defs => Plutarch.Bool.PPartialOrd (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Compose @{Plutarch.Internal.PType} @{[Plutarch.DataRepr.Internal.PLabeledType]} Plutarch.Bool.POrd Plutarch.DataRepr.Internal.PDataRecord) defs => Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (ys :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.DataRepr.Internal.PDataSum ys) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.DataRepr.Internal.PDataSum ys))
instance forall (l :: [Plutarch.DataRepr.Internal.PLabeledType]). Data.SOP.Constraint.SListI @{Plutarch.DataRepr.Internal.PLabeledType} l => Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataRecord l)
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (label :: GHC.Types.Symbol) (x :: Plutarch.Internal.PType). (Data.SOP.Constraint.All @Plutarch.DataRepr.Internal.PLabeledType (Data.SOP.Constraint.Top @{Plutarch.DataRepr.Internal.PLabeledType}) xs, GHC.TypeLits.KnownSymbol label, Plutarch.Builtin.PIsData x, Plutarch.Show.PShow x, Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper xs)) => Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) xs))
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.DataRepr.Internal.PDataRecordShowHelper as)
instance Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (label :: GHC.Types.Symbol) (x :: Plutarch.Internal.PType). (Data.SOP.Constraint.All @Plutarch.DataRepr.Internal.PLabeledType (Data.SOP.Constraint.Top @{Plutarch.DataRepr.Internal.PLabeledType}) xs, GHC.TypeLits.KnownSymbol label, Plutarch.Builtin.PIsData x, Plutarch.Show.PShow x, Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper xs)) => Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) xs))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Bool.PEq (Plutarch.DataRepr.Internal.PDataRecord xs)
instance Plutarch.Bool.PPartialOrd (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (x :: Plutarch.Internal.PType) (label :: GHC.Types.Symbol). (Plutarch.Bool.POrd x, Plutarch.Builtin.PIsData x) => Plutarch.Bool.PPartialOrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ('[] @Plutarch.DataRepr.Internal.PLabeledType)))
instance forall (x :: Plutarch.Internal.PType) (label :: GHC.Types.Symbol). (Plutarch.Bool.POrd x, Plutarch.Builtin.PIsData x) => Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ('[] @Plutarch.DataRepr.Internal.PLabeledType)))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (x :: Plutarch.Internal.PType) (x' :: Plutarch.DataRepr.Internal.PLabeledType) (label :: GHC.Types.Symbol). (Data.SOP.Constraint.SListI @{Plutarch.DataRepr.Internal.PLabeledType} xs, Plutarch.Bool.POrd x, Plutarch.Builtin.PIsData x, Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs))) => Plutarch.Bool.PPartialOrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs)))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (x :: Plutarch.Internal.PType) (x' :: Plutarch.DataRepr.Internal.PLabeledType) (label :: GHC.Types.Symbol). (Data.SOP.Constraint.SListI @{Plutarch.DataRepr.Internal.PLabeledType} xs, Plutarch.Bool.POrd x, Plutarch.Builtin.PIsData x, Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs))) => Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs)))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Builtin.PIsData (Plutarch.DataRepr.Internal.PDataRecord xs)

module Plutarch.Either

-- | Scott-encoded <a>Either</a>.
data PEither (a :: PType) (b :: PType) (s :: S)
PLeft :: Term s a -> PEither (a :: PType) (b :: PType) (s :: S)
PRight :: Term s b -> PEither (a :: PType) (b :: PType) (s :: S)

-- | <tt>Data</tt>-encoded <a>Either</a>.
--   
--   @since WIP
data PEitherData (a :: S -> Type) (b :: S -> Type) (s :: S)
PDLeft :: Term s (PAsData a) -> PEitherData (a :: S -> Type) (b :: S -> Type) (s :: S)
PDRight :: Term s (PAsData b) -> PEitherData (a :: S -> Type) (b :: S -> Type) (s :: S)

-- | Make a <tt>Data</tt>-encoded <tt>Left</tt>.
--   
--   @since WIP
pdleft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData a => Term s (a :--> PEitherData a b)

-- | Make a <tt>Data</tt>-encoded <tt>Right</tt>.
--   
--   @since WIP
pdright :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData b => Term s (b :--> PEitherData a b)

-- | Eliminator for <a>PEitherData</a>.
--   
--   @since WIP
peitherData :: forall (a :: S -> Type) (b :: S -> Type) (r :: S -> Type) (s :: S). (PIsData a, PIsData b) => Term s ((a :--> r) :--> ((b :--> r) :--> (PEitherData a b :--> r)))

-- | Verifies if a <a>PEitherData</a> is a <a>PDLeft</a>. Less code than
--   using <a>peitherData</a>, as it doesn't need to inspect the contents.
--   
--   @since WIP
pdisLeft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEitherData a b :--> PBool)

-- | As <a>pdisLeft</a>, except verifies whether we have a <a>PDRight</a>.
--   
--   @since WIP
pdisRight :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEitherData a b :--> PBool)

-- | Return the value inside a <tt>PDEither</tt> if it's a <a>PDLeft</a>,
--   error otherwise.
--   
--   @since WIP
pdfromLeft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData a => Term s (PEitherData a b :--> a)

-- | As <a>pdfromLeft</a>, but yields a value if given a <a>PDRight</a>
--   instead.
--   
--   @since WIP
pdfromRight :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData b => Term s (PEitherData a b :--> b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Show.PShow b) => Plutarch.Show.PShow (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Bool.PEq a, Plutarch.Bool.PEq b) => Plutarch.Bool.PEq (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Either.PEither a b s)
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type) (b :: Plutarch.Internal.S -> GHC.Types.Type). (Plutarch.Bool.PPartialOrd a, Plutarch.Bool.PPartialOrd b, Plutarch.Builtin.PIsData a, Plutarch.Builtin.PIsData b) => Plutarch.Bool.POrd (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type) (b :: Plutarch.Internal.S -> GHC.Types.Type). (Plutarch.Builtin.PIsData a, Plutarch.Builtin.PIsData b, Plutarch.Show.PShow a, Plutarch.Show.PShow b) => Plutarch.Show.PShow (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type) (b :: Plutarch.Internal.S -> GHC.Types.Type). Plutarch.Bool.PEq (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type) (b :: Plutarch.Internal.S -> GHC.Types.Type) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Either.PEitherData a b s)
instance forall a b. (Plutarch.DataRepr.Internal.PConstantData a, Plutarch.DataRepr.Internal.PConstantData b) => Plutarch.Lift.PConstantDecl (Data.Either.Either a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Bool.PPartialOrd a, Plutarch.Bool.PPartialOrd b, Plutarch.Builtin.PIsData a, Plutarch.Builtin.PIsData b) => Plutarch.Bool.PPartialOrd (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type) (b :: Plutarch.Internal.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type) (b :: Plutarch.Internal.S -> GHC.Types.Type). Plutarch.Builtin.PIsData (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a, Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData b) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a, Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData b) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Either.PEitherData a b))
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.DataRepr.Internal.PLiftData a, Plutarch.DataRepr.Internal.PLiftData b) => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Either.PEither a b)

module Plutarch.DataRepr.Internal.Field

-- | Class allowing <tt>letFields</tt> to work for a PType, usually via
--   <tt>PIsDataRepr</tt>, but is derived for some other types for
--   convenience.
class PDataFields (a :: PType) where {
    
    -- | Fields in HRec bound by <tt>letFields</tt>
    type PFields a :: [PLabeledType];
    type PFields a = Helper (PInner a);
}

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: PDataFields a => Term s a -> Term s (PDataRecord (PFields a))

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: (PDataFields a, PDataFields (PInner a), PFields (PInner a) ~ PFields a) => Term s a -> Term s (PDataRecord (PFields a))

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name b p s a as n. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)
class BindFields (ps :: [PLabeledType]) (bs :: [ToBind])

-- | Bind all the fields in a <tt>PDataList</tt> term to a corresponding
--   HList of Terms.
--   
--   A continuation is returned to enable sharing of the generated
--   bound-variables.
bindFields :: BindFields ps bs => Proxy bs -> Term s (PDataRecord ps) -> TermCont s (HRec (BoundTerms ps bs s))

-- | Map <a>BindField</a> over <tt>[PLabeledType]</tt>, with <tt>Skips</tt>
--   removed at tail
type family Bindings (ps :: [PLabeledType]) (fs :: [Symbol]) :: [ToBind]

-- | Get the <a>Term</a> representations to be bound based on the result of
--   <a>Bindings</a>.
type family BoundTerms ps bs s

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

-- | The <a>HRec</a> yielded by 'pletFields @fs t'.
type HRecOf t fs s = HRec (BoundTerms (PFields t) (Bindings (PFields t) fs) s)

-- | Constrain an <a>HRec</a> to contain the specified fields from the
--   given Plutarch type.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   import Plutarch.Prelude
--   import Plutarch.DataRepr
--   
--   newtype PFooType s = PFooType (Term s (PDataRecord '["frst" ':= PInteger, "scnd" ':= PBool, "thrd" ':= PString]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (Generic)
--     deriving anyclass (PIsDataRepr)
--     deriving
--       (PlutusType, PIsData, PDataFields, PEq)
--       via PIsDataReprInstances PFooType
--   
--   foo :: PMemberFields PFooType '["scnd", "frst"] s as =&gt; HRec as -&gt; Term s PInteger
--   foo h = pif (getField <tt>"scnd" h) (getField </tt>"frst" h) 0
--   </pre>
type family PMemberFields t fs s as

-- | Single field version of <a>PMemberFields</a>.
type family PMemberField t name s as
data HRec as
[HNil] :: HRec '[]
[HCons] :: Labeled name a -> HRec as -> HRec ('(name, a) ': as)
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[$sel:unLabeled:Labeled] :: Labeled sym a -> a

-- | Index a <a>HRec</a> with a field in a provided list of data fields.
--   Implicitly unwraps `PAsData a` to <tt>a</tt> when necessary.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>

-- | <i>Deprecated: please use getField from GHC.Records</i>
hrecField :: forall name c as a b s. (ElemOf name a as, Term s (PAsData b) ~ a, PFromDataable b c) => HRec as -> Term s c
instance forall (l :: GHC.Types.Symbol) (p :: Plutarch.Internal.PType) (ps :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType (l 'Plutarch.DataRepr.Internal.:= p) ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Bind ('[] @Plutarch.DataRepr.Internal.Field.ToBind))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (l :: GHC.Types.Symbol) (p :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType (l 'Plutarch.DataRepr.Internal.:= p) ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Bind bs)
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ps)) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ps))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ps)))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ps))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType) (p6 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ((':) @Plutarch.DataRepr.Internal.PLabeledType p6 ps)))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType) (p6 :: Plutarch.DataRepr.Internal.PLabeledType) (p7 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ((':) @Plutarch.DataRepr.Internal.PLabeledType p6 ((':) @Plutarch.DataRepr.Internal.PLabeledType p7 ps))))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))))))
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.DataRepr.Internal.PDataRecord as)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.DataRepr.Internal.PDataSum ((':) @[Plutarch.DataRepr.Internal.PLabeledType] as ('[] @[Plutarch.DataRepr.Internal.PLabeledType])))
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.DataRepr.Internal.Field.PDataFields a) => Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Builtin.PAsData a)

module Plutarch.DataRepr

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
newtype PDataSum defs s
PDataSum :: NS (Compose (Term s) PDataRecord) defs -> PDataSum defs s

-- | If there is only a single variant, then we can safely extract it.
punDataSum :: Term s (PDataSum '[def] :--> PDataRecord def)

-- | Try getting the nth variant. Errs if it's another variant.
ptryIndexDataSum :: KnownNat n => Proxy n -> Term s (PDataSum (def ': defs) :--> PDataRecord (IndexList n (def ': defs)))
data DataReprHandlers (out :: PType) (defs :: [[PLabeledType]]) (s :: S)
[DRHNil] :: DataReprHandlers out '[] s
[DRHCons] :: (Term s (PDataRecord def) -> Term s out) -> DataReprHandlers out defs s -> DataReprHandlers out (def ': defs) s

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)
[PDCons] :: forall name_x x xs s. PUnLabel name_x ~ x => Term s (PAsData x) -> Term s (PDataRecord xs) -> PDataRecord (name_x ': xs) s
[PDNil] :: PDataRecord '[] s

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label ':= a) ': l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])
data PLabeledType
(:=) :: Symbol -> PType -> PLabeledType

-- | Safely index a <a>PDataRecord</a>.
pindexDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord as) -> Term s (PAsData (PUnLabel (IndexList n as)))

-- | Safely drop the first n items of a <a>PDataRecord</a>.
pdropDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord xs) -> Term s (PDataRecord (Drop n xs))

-- | For deriving <tt>PConstant</tt> for a wrapped type represented by a
--   builtin type, see <tt>DerivePConstantViaNewtype</tt>.
newtype DerivePConstantViaData (h :: Type) (p :: PType)

-- | The Haskell type for which @PConstant is being derived.
DerivePConstantViaData :: h -> DerivePConstantViaData (h :: Type) (p :: PType)

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaData</tt>.
--   
--   A type <tt>Foo a</tt> is considered <a>ConstantableData</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   <li>The newtype has <tt>FromData</tt> and <tt>ToData</tt>
--   instances</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   data Bar a = Bar a deriving stock (GHC.Generic)
--   
--   PlutusTx.makeLift ''Bar
--   PlutusTx.makeIsDataIndexed ''Bar [('Bar, 0)]
--   
--   data PBar (a :: PType) (s :: S)
--     = PBar (Term s (PDataRecord '["_0" ':= a]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (SOP.Generic, PIsDataRepr)
--     deriving (PlutusType, PIsData, PDataFields) via PIsDataReprInstances (PBar a)
--   
--   instance
--     forall a.
--     PLiftData a =&gt;
--     PUnsafeLiftDecl (PBar a)
--     where
--     type PLifted (PBar a) = Bar (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaData
--         (Bar a)
--         (PBar (PConstanted a))
--     )
--     instance
--       PConstantData a =&gt;
--       PConstantDecl (Bar a)
--   </pre>
type PConstantData h = (PConstant h, FromData h, ToData h, PIsData (PConstanted h))
type PLiftData p = (PLift p, FromData (PLifted p), ToData (PLifted p), PIsData p)
data PlutusTypeData

-- | Class allowing <tt>letFields</tt> to work for a PType, usually via
--   <tt>PIsDataRepr</tt>, but is derived for some other types for
--   convenience.
class PDataFields (a :: PType) where {
    
    -- | Fields in HRec bound by <tt>letFields</tt>
    type PFields a :: [PLabeledType];
    type PFields a = Helper (PInner a);
}

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: PDataFields a => Term s a -> Term s (PDataRecord (PFields a))

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: (PDataFields a, PDataFields (PInner a), PFields (PInner a) ~ PFields a) => Term s a -> Term s (PDataRecord (PFields a))

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name b p s a as n. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)
data HRec as

-- | The <a>HRec</a> yielded by 'pletFields @fs t'.
type HRecOf t fs s = HRec (BoundTerms (PFields t) (Bindings (PFields t) fs) s)

-- | Constrain an <a>HRec</a> to contain the specified fields from the
--   given Plutarch type.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   import Plutarch.Prelude
--   import Plutarch.DataRepr
--   
--   newtype PFooType s = PFooType (Term s (PDataRecord '["frst" ':= PInteger, "scnd" ':= PBool, "thrd" ':= PString]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (Generic)
--     deriving anyclass (PIsDataRepr)
--     deriving
--       (PlutusType, PIsData, PDataFields, PEq)
--       via PIsDataReprInstances PFooType
--   
--   foo :: PMemberFields PFooType '["scnd", "frst"] s as =&gt; HRec as -&gt; Term s PInteger
--   foo h = pif (getField <tt>"scnd" h) (getField </tt>"frst" h) 0
--   </pre>
type family PMemberFields t fs s as

-- | Single field version of <a>PMemberFields</a>.
type family PMemberField t name s as

module Plutarch.TermCont
hashOpenTerm :: Term s a -> TermCont s Dig
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
($sel:runTermCont:TermCont) :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Like <a>plet</a> but works in a <a>TermCont</a> monad
pletC :: Term s a -> TermCont s (Term s a)

-- | Like <a>pmatch</a> but works in a <a>TermCont</a> monad
pmatchC :: PlutusType a => Term s a -> TermCont s (a s)

-- | Like <a>pletFields</a> but works in a <a>TermCont</a> monad.
pletFieldsC :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> TermCont @b s (HRec (BoundTerms ps bs s))

-- | Like <tt>ptrace</tt> but works in a <a>TermCont</a> monad.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   foo :: Term s PUnit
--   foo = unTermCont $ do
--     ptraceC "returning unit!"
--     pure $ pconstant ()
--   </pre>
ptraceC :: Term s PString -> TermCont s ()

-- | Trace a message and raise error if <tt>cond</tt> is false. Otherwise,
--   continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   onlyAllow42 :: Term s (PInteger :--&gt; PUnit)
--   onlyAllow42 = plam $ i -&gt; unTermCont $ do
--     pguardC "expected 42" $ i #== 42
--     pure $ pconstant ()
--   </pre>
pguardC :: Term s PString -> Term s PBool -> TermCont s ()

-- | Stop computation and return given term if <tt>cond</tt> is false.
--   Otherwise, continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   is42 :: Term s (PInteger :--&gt; PBool)
--   is42 = plam $ i -&gt; unTermCont $ do
--     pguardC' (pconstant False) $ i #== 42
--     pure $ pconstant True
--   </pre>
pguardC' :: Term s a -> Term s PBool -> TermCont @a s ()

-- | <a>TermCont</a> producing version of <a>ptryFrom</a>.
ptryFromC :: forall b r a s. PTryFrom a b => Term s a -> TermCont @r s (Term s b, Reduce (PTryFromExcess a b s))

-- | Escape with a particular value on expecting <a>PJust</a>. For use in
--   monadic context.
--   
--   @since WIP
pexpectJustC :: forall (a :: S -> Type) (r :: S -> Type) (s :: S). Term s r -> Term s (PMaybe a) -> TermCont @r s (Term s a)

module Plutarch.Positive
data PPositive s

-- | Build a <a>PPositive</a> from a <a>PInteger</a>. Yields
--   <a>PNothing</a> if argument is zero.
ppositive :: Term s (PInteger :--> PMaybe PPositive)

-- | Partial version of <a>PPositive</a>. Errors if argument is zero.
ptryPositive :: Term s (PInteger :--> PPositive)

-- | @since WIP
data Positive

-- | @since WIP
mkPositive :: Integer -> Maybe Positive
instance Plutarch.Show.PShow Plutarch.Positive.PPositive
instance Plutarch.Integer.PIntegral Plutarch.Positive.PPositive
instance Plutarch.Bool.POrd Plutarch.Positive.PPositive
instance Plutarch.Bool.PPartialOrd Plutarch.Positive.PPositive
instance Plutarch.Bool.PEq Plutarch.Positive.PPositive
instance Plutarch.Builtin.PIsData Plutarch.Positive.PPositive
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Positive.PPositive
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Positive.PPositive s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Positive.Flip @{k2} @{k1} f a b)
instance GHC.Classes.Ord Plutarch.Positive.Positive
instance GHC.Classes.Eq Plutarch.Positive.Positive
instance GHC.Show.Show Plutarch.Positive.Positive
instance Plutarch.Lift.PConstantDecl Plutarch.Positive.Positive
instance Test.QuickCheck.Arbitrary.Arbitrary Plutarch.Positive.Positive
instance Test.QuickCheck.Arbitrary.CoArbitrary Plutarch.Positive.Positive
instance Prettyprinter.Internal.Pretty Plutarch.Positive.Positive
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Positive.PPositive
instance Test.QuickCheck.Function.Function Plutarch.Positive.Positive
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Positive.PPositive)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Positive.PPositive
instance Plutarch.Num.PNum Plutarch.Positive.PPositive
instance Plutarch.TryFrom.PTryFrom Plutarch.Integer.PInteger Plutarch.Positive.PPositive

module Plutarch.Rational

-- | Note: This type is _not_ the synonym of <a>Rational</a>.
data PRational s
PRational :: Term s PInteger -> Term s PPositive -> PRational s
preduce :: Term s (PRational :--> PRational)
pnumerator :: Term s (PRational :--> PInteger)
pdenominator :: Term s (PRational :--> PPositive)
pfromInteger :: Term s (PInteger :--> PRational)
pround :: Term s (PRational :--> PInteger)
ptruncate :: Term s (PRational :--> PInteger)
pproperFraction :: Term s (PRational :--> PPair PInteger PRational)
class PFractional (a :: PType)
(#/) :: PFractional a => Term s a -> Term s a -> Term s a
precip :: PFractional a => Term s (a :--> a)
pfromRational :: PFractional a => Term s (PRational :--> a)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Rational.PRational
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Rational.PRational s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Rational.Flip @{k2} @{k1} f a b)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Rational.PRational)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Num.PNum a, Plutarch.Rational.PFractional a) => GHC.Real.Fractional (Plutarch.Internal.Term s a)
instance Plutarch.Rational.PFractional Plutarch.Rational.PRational
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Rational.PRational
instance Plutarch.Bool.PEq Plutarch.Rational.PRational
instance Plutarch.Show.PShow Plutarch.Rational.PRational
instance Plutarch.Builtin.PIsData Plutarch.Rational.PRational
instance Plutarch.Bool.PPartialOrd Plutarch.Rational.PRational
instance Plutarch.Bool.POrd Plutarch.Rational.PRational
instance Plutarch.Num.PNum Plutarch.Rational.PRational

module Plutarch.Enum

-- | A notion of 'next' value. More formally, instances of this type class
--   are discrete linear orders with no maximal element.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><pre>x /= psuccessor x</pre></li>
--   <li><tt>y &lt; x</tt> <tt>=</tt> <tt>psuccessor y &lt;= x</tt></li>
--   <li><tt>x &lt; psuccessor y</tt> <tt>=</tt> <tt>x &lt;= y</tt></li>
--   </ol>
--   
--   If you define <a>psuccessorN</a>, you must also ensure the following
--   hold; the default implementation ensures this.
--   
--   <ol>
--   <li><tt>psuccessorN 1</tt> <tt>=</tt> <tt>psuccessor</tt></li>
--   <li><tt>psuccessorN n . psuccessorN m</tt> <tt>=</tt> <tt>psuccessorN
--   (n + m)</tt></li>
--   </ol>
--   
--   Law 1 ensures no value is its own successor. Laws 2 and 3 ensure that
--   there are no 'gaps': every value is 'reachable' from any lower value
--   by a finite number of applications of <tt>successor</tt>.
--   
--   @since WIP
class POrd a => PCountable (a :: S -> Type)

-- | @since WIP
psuccessor :: forall (s :: S). PCountable a => Term s (a :--> a)

-- | The default implementation of this function is inefficient: if at all
--   possible, give instances an optimized version that doesn't require
--   recursion.
--   
--   @since WIP
psuccessorN :: forall (s :: S). PCountable a => Term s (PPositive :--> (a :--> a))

-- | Similar to <a>PCountable</a>, but has the ability to get a 'previous'
--   value as well. More formally, instances of this type class are
--   discrete linear orders with no maximal or minimal element.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>ppredecessor . psuccessor</tt> <tt>=</tt> <tt>psuccessor .
--   ppredecessor</tt> <tt>=</tt> <tt>id</tt></li>
--   </ol>
--   
--   If you define <a>ppredecessorN</a>, you must also ensure the following
--   hold; the default implementation ensures this.
--   
--   <ol>
--   <li><tt>ppredecessorN 1</tt> <tt>=</tt> <tt>ppredecessor</tt></li>
--   <li><tt>ppredecessorN n . ppredecessorN m</tt> <tt>=</tt>
--   <tt>ppredecessorN (n + m)</tt></li>
--   </ol>
--   
--   From Law 1, we obtain the following theorem:
--   
--   <ul>
--   <li><pre>x /= predecessor x</pre></li>
--   </ul>
--   
--   @since WIP
class PCountable a => PEnumerable (a :: S -> Type)

-- | @since WIP
ppredecessor :: forall (s :: S). PEnumerable a => Term s (a :--> a)

-- | The default implementation of this function is inefficient: if at all
--   possible, give instances an optimized version that doesn't require
--   recursion.
--   
--   @since WIP
ppredecessorN :: forall (s :: S). PEnumerable a => Term s (PPositive :--> (a :--> a))
instance Plutarch.Enum.PEnumerable Plutarch.Integer.PInteger
instance Plutarch.Enum.PCountable Plutarch.Integer.PInteger
instance Plutarch.Enum.PCountable Plutarch.Positive.PPositive


-- | Conversions between various types.
--   
--   @since WIP
module Plutarch.Convert

-- | Type designating whether a conversion should be most-significant-first
--   or most-significant-last. See <a>CIP-121</a> for more details on this.
--   
--   @since WIP
data PEndianness (s :: S)

-- | Indicates the conversion should be most-significant-first.
--   
--   @since WIP
pmostSignificantFirst :: forall (s :: S). Term s PEndianness

-- | Indicates the conversion should be most-significant-last.
--   
--   @since WIP
pmostSignificantLast :: forall (s :: S). Term s PEndianness

-- | Convert a <a>PByteString</a> into a <a>PInteger</a>, as per
--   <a>CIP-121</a>.
--   
--   @since WIP
pbyteStringToInteger :: forall (s :: S). Term s PEndianness -> Term s (PByteString :--> PInteger)

-- | Convert a (non-negative) <a>PInteger</a> into a <a>PByteString</a>.
--   This will produce a result of the minimal size required: if you want
--   to specify a size, use <a>pintegerToByteStringSized</a>. For details,
--   see <a>CIP-121</a>.
--   
--   <h1>Note</h1>
--   
--   This conversion is unsafe, as it will error when given a non-negative
--   integer.
pintegerToByteString :: forall (s :: S). Term s PEndianness -> Term s (PInteger :--> PByteString)

-- | As <a>pintegerToByteString</a>, but allows specifying a required size.
--   If a size larger than the minimum is specified, the result will be
--   padded with zero bytes, positioned according to the endianness
--   argument.
--   
--   For more details, see <a>CIP-121</a>.
--   
--   <h1>Note</h1>
--   
--   This conversion is unsafe. In addition to the reasons for
--   <tt>punsafeIntegerToByteString</tt> being unsafe, this will also error
--   if the requested size is too large (currently 8192 is the limit) or
--   too small to fit the specified <a>PInteger</a>.
pintegerToByteStringSized :: forall (s :: S). Term s PEndianness -> Term s (PPositive :--> (PInteger :--> PByteString))
instance Plutarch.Bool.POrd Plutarch.Convert.PEndianness
instance Plutarch.Bool.PPartialOrd Plutarch.Convert.PEndianness
instance Plutarch.Bool.PEq Plutarch.Convert.PEndianness
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Convert.PEndianness
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Convert.PEndianness s)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Convert.PEndianness

module Plutarch.Prelude
data (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->
data PDelayed (a :: PType) (s :: S)
data Term (s :: S) (a :: PType)

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a
plam :: forall c. (PLamN a b s, HasCallStack) => (Term s c -> a) -> Term s (c :--> b)

-- | Lambda Application.
papp :: Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #

-- | Let bindings.
--   
--   This is approximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))
pthrow :: HasCallStack => Text -> Term s a

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = TYPE LiftedRep
data S

-- | Shorthand for Plutarch types.
type PType = S -> Type
class PlutusType (a :: PType) where {
    type PInner a :: PType;
    type PInner a = DerivedPInner (DPTStrat a) a;
    type PCovariant' a = All2 PCovariant'' (PCode a);
    type PContravariant' a = All2 PContravariant'' (PCode a);
    type PVariant' a = All2 PVariant'' (PCode a);
}
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType)
type DPTStrat a :: Type
data PlutusTypeScott
data PlutusTypeNewtype
data PlutusTypeData

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s

-- | Plutus BuiltinInteger
data PInteger s
class PIntegral a
pdiv :: PIntegral a => Term s (a :--> (a :--> a))
pdiv :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pmod :: PIntegral a => Term s (a :--> (a :--> a))
pmod :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pquot :: PIntegral a => Term s (a :--> (a :--> a))
pquot :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
prem :: PIntegral a => Term s (a :--> (a :--> a))
prem :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))

-- | Note: This type is _not_ the synonym of <a>Rational</a>.
data PRational s
PRational :: Term s PInteger -> Term s PPositive -> PRational s
pnumerator :: Term s (PRational :--> PInteger)
pdenominator :: Term s (PRational :--> PPositive)
pround :: Term s (PRational :--> PInteger)

-- | Plutus <tt>BuiltinBool</tt>
data PBool (s :: S)
PTrue :: PBool (s :: S)
PFalse :: PBool (s :: S)
class PEq t
(#==) :: PEq t => Term s t -> Term s t -> Term s PBool
(#==) :: (PEq t, PGeneric t, PlutusType t, All2 PEq (PCode t)) => Term s t -> Term s t -> Term s PBool
infix 4 #==

-- | Partial ordering relation.
--   
--   <h1>Laws</h1>
--   
--   <a>#&lt;=</a> must form a partial order. More precisely:
--   
--   <ol>
--   <li><tt>x #&lt;= x</tt> <tt>=</tt> <tt>True</tt> (<tt>#&lt;=</tt> is
--   reflexive)</li>
--   <li><tt>(x #&lt;= y) #&amp;&amp; (y #&lt;= x)</tt> <tt>=</tt> <tt>x
--   #== y</tt> (<tt>#&lt;=</tt> is anti-symmetric)</li>
--   <li><tt>(x #&lt;= y) #&amp;&amp; (y #&lt;= z)</tt> <tt>=</tt> <tt>x
--   #&lt;= z</tt> (@#&lt;= is transitive)</li>
--   </ol>
--   
--   Furthermore, <a>#&lt;</a> must be an equivalent strict partial order
--   to <a>#&lt;=</a>:
--   
--   <ol>
--   <li><tt>x #&lt;= y</tt> <tt>=</tt> <tt>(x #&lt; y) #|| (x #==
--   y)</tt></li>
--   <li><tt>x #&lt; x</tt> <tt>=</tt> <tt>False</tt> (<tt>#&lt;</tt> is
--   irreflexive)</li>
--   <li><tt>x #&lt; y</tt> <tt>=</tt> <tt>pnot (y #&lt; x)</tt>
--   (<tt>#&lt;</tt> is asymmetric)</li>
--   <li><tt>(x #&lt; y) #&amp;&amp; (y #&lt; z)</tt> <tt>=</tt> <tt>x
--   #&lt; z</tt> (<tt>#&lt;</tt> is transitive)</li>
--   </ol>
--   
--   Lastly, if you define <a>#&gt;=</a> or <a>#&gt;</a>, ensure that the
--   following also hold:
--   
--   <ol>
--   <li><tt>x #&gt; y</tt> <tt>=</tt> <tt>y #&lt; x</tt></li>
--   <li><tt>x #&gt;= y</tt> <tt>=</tt> <tt>pnot (x #&lt; y)</tt></li>
--   </ol>
--   
--   The default implementations of <a>#&gt;=</a> and <a>#&gt;</a> ensure
--   these laws.
class PEq t => PPartialOrd t
(#<=) :: PPartialOrd t => Term s t -> Term s t -> Term s PBool
(#<=) :: (PPartialOrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool
(#<) :: PPartialOrd t => Term s t -> Term s t -> Term s PBool
(#<) :: (PPartialOrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool

-- | @since WIP
(#>=) :: forall (s :: S). PPartialOrd t => Term s t -> Term s t -> Term s PBool

-- | @since WIP
(#>) :: forall (s :: S). PPartialOrd t => Term s t -> Term s t -> Term s PBool
infix 4 #<=
infix 4 #<
infix 4 #>=
infix 4 #>

-- | Total ordering relation.
--   
--   <h1>Laws</h1>
--   
--   <a>pmax</a> and <a>pmin</a> must form a commutative semiring without
--   identity elements, where addition also distributes over
--   multiplication. More precisely:
--   
--   <ol>
--   <li><tt>pmax x y</tt> <tt>=</tt> <tt>pmax y x</tt> (<tt>pmax</tt> is
--   commutative)</li>
--   <li><tt>pmin x y</tt> <tt>=</tt> <tt>pmin y x</tt> (<tt>pmin</tt> is
--   commutative)</li>
--   <li><tt>pmax x (pmax y z)</tt> <tt>=</tt> <tt>pmax (pmax x y) z</tt>
--   (<tt>pmax</tt> is associative)</li>
--   <li><tt>pmin x (pmin y z)</tt> <tt>=</tt> <tt>pmin (pmin x y) z</tt>
--   (<tt>pmin</tt> is associative)</li>
--   <li><tt>pmax x (pmin y z)</tt> <tt>=</tt> <tt>pmin (pmax x y) (pmax x
--   z)</tt> (<tt>pmax</tt> distributes over <tt>pmin</tt>)</li>
--   <li><tt>pmin x (pmax y z)</tt> <tt>=</tt> <tt>pmax (pmin x y) (pmin x
--   z)</tt> (<tt>pmin</tt> distributes over <tt>pmax</tt>)</li>
--   </ol>
--   
--   Furthermore, the following must hold relative <a>#&lt;</a>:
--   
--   <ol>
--   <li><tt>pmin x y</tt> <tt>=</tt> <tt>if (x #&lt; y) then x else
--   y</tt></li>
--   <li><tt>pmax x y</tt> <tt>=</tt> <tt>if (x #&lt; y) then y else
--   x</tt></li>
--   </ol>
--   
--   Laws 7 and 8 are also the defaults, as for most types, this is the
--   best you can do.
class PPartialOrd t => POrd t

-- | @since WIP
pmax :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t

-- | @since WIP
pmin :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t

-- | Lazy if-then-else.
pif :: Term s PBool -> Term s a -> Term s a -> Term s a

-- | Boolean negation for <a>PBool</a> terms.
pnot :: Term s (PBool :--> PBool)

-- | Lazily evaluated boolean and for <a>PBool</a> terms.
(#&&) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 3 #&&

-- | Lazily evaluated boolean or for <a>PBool</a> terms.
(#||) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 2 #||

-- | Plutus <tt>BuiltinByteString</tt>
data PByteString s

-- | A Plutarch-level representation of bytes.
--   
--   <h1>Note =</h1>
--   
--   This type is intentionally quite restrictive, as it's not really meant
--   to be computed with. Instead, it ensures certain operations' type
--   safety while also allowing more sensible signatures. If you want to do
--   anything with <a>PByte</a>s, we recommend converting them to
--   <a>PInteger</a>s first.
--   
--   @since WIP
data PByte (s :: S)

-- | Type designating whether logical operations should use padding or
--   truncation semantics. See <a>CIP-122</a> for more details on this.
--   
--   @since WIP
data PLogicOpSemantics (s :: S)

-- | Indicates that padding semantics should be used.
--   
--   @since WIP
ppadding :: forall (s :: S). Term s PLogicOpSemantics

-- | Indicates that truncation semantics should be used.
--   
--   @since WIP
ptruncation :: forall (s :: S). Term s PLogicOpSemantics

-- | Construct a <a>PByteString</a> of the specified length (0 if negative)
--   consisting entirely of zero bytes.
--   
--   @since WIP
pzeroesBS :: forall (s :: S). Term s (PInteger :--> PByteString)

-- | Construct a <a>PByteString</a> of the specified length (0 if negative)
--   consisting entirely of ones; that is, where every byte is
--   <tt>0xFF</tt>.
--   
--   @since WIP
ponesBS :: forall (s :: S). Term s (PInteger :--> PByteString)

-- | Given a desired length and a <a>PByte</a>, construct a
--   <a>PByteString</a> of the specified length (0 if negative) consisting
--   entirely of that <a>PByte</a>.
--   
--   @since WIP
preplicateBS :: forall (s :: S). Term s (PInteger :--> (PByte :--> PByteString))

-- | Perform the logical AND of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
pandBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical OR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
porBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical XOR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
pxorBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical complement of a <a>PByteString</a>, as per
--   <a>CIP-122</a>.
--   
--   @since WIP
pcomplementBS :: forall (s :: S). Term s (PByteString :--> PByteString)

-- | Prepend a <a>PByte</a> to a 'PByteString.
--   
--   @since WIP
pconsBS :: Term s (PByte :--> (PByteString :--> PByteString))

-- | Slice a <a>PByteString</a> with given start index and slice length.
--   
--   <pre>
--   &gt;&gt;&gt; (pslice # 2 # 3 phexByteStr "4102afde5b2a") #== phexByteStr "afde5b"
--   </pre>
psliceBS :: Term s (PInteger :--> (PInteger :--> (PByteString :--> PByteString)))

-- | Find the length of a <a>PByteString</a>.
plengthBS :: Term s (PByteString :--> PInteger)

-- | Given a valid index into a <a>PByteString</a>, returns the
--   <a>PByte</a> at that index. Will crash if given an out-of-bounds
--   index.
--   
--   @since WIP
pindexBS :: Term s (PByteString :--> (PInteger :--> PByte))

-- | Convert a <a>PByte</a> into its corresponding <a>PInteger</a>.
--   
--   @since WIP
pbyteToInteger :: Term s (PByte :--> PInteger)

-- | Try to convert a <a>PInteger</a> into its corresponding <a>PByte</a>.
--   This operation is checked, and will error if given a negative
--   <a>PInteger</a>, or one too large to fit into a byte.
--   
--   @since WIP
pintegerToByte :: Term s (PInteger :--> PByte)

-- | Interpret a hex string as a PByteString.
phexByteStr :: HasCallStack => String -> Term s PByteString

-- | Plutus <tt>BuiltinString</tt> values
data PString s

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)
data PUnit s
PUnit :: PUnit s

-- | Plutarch types that behave like lists.
class PListLike (list :: PType -> PType) where {
    type PElemConstraint list (a :: PType) :: Constraint;
}

-- | Canonical eliminator for list-likes.
pelimList :: (PListLike list, PElemConstraint list a) => (Term s a -> Term s (list a) -> Term s r) -> Term s r -> Term s (list a) -> Term s r

-- | Cons an element onto an existing list.
pcons :: (PListLike list, PElemConstraint list a) => Term s (a :--> (list a :--> list a))

-- | The empty list
pnil :: (PListLike list, PElemConstraint list a) => Term s (list a)

-- | Return the first element of a list. Partial, throws an error upon
--   encountering an empty list.
phead :: (PListLike list, PElemConstraint list a) => Term s (list a :--> a)

-- | Take the tail of a list, meaning drop its head. Partial, throws an
--   error upon encountering an empty list.
ptail :: (PListLike list, PElemConstraint list a) => Term s (list a :--> list a)

-- | <i> O(1) </i>. Check if a list is empty
pnull :: (PListLike list, PElemConstraint list a) => Term s (list a :--> PBool)

-- | 'PIsListLike list a' constraints <tt>list</tt> be a <a>PListLike</a>
--   with valid element type, <tt>a</tt>.
type PIsListLike list a = (PListLike list, PElemConstraint list a)

-- | <i> O(min(n, m)) </i>. Check if two lists are equal.
plistEquals :: (PIsListLike list a, PEq a) => Term s (list a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check if element is in the list
pelem :: (PIsListLike list a, PEq a) => Term s (a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the Plutarch
--   level, not infix and with arguments reversed, errors if the specified
--   index is greater than or equal to the lists length
pelemAt :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(n) </i>. Count the number of elements in the list
plength :: PIsListLike list a => Term s (list a :--> PInteger)

-- | Index a BuiltinList, throwing an error if the index is out of bounds.
ptryIndex :: PIsListLike list a => Natural -> Term s (list a) -> Term s a

-- | Drop the first n fields of a List.
--   
--   The term will be statically generated as repeated applications of
--   <a>ptail</a>, which will be more efficient in many circumstances.
pdrop :: PIsListLike list a => Natural -> Term s (list a) -> Term s (list a)

-- | <i> O(1) </i>. Create a singleton list from an element
psingleton :: PIsListLike list a => Term s (a :--> list a)

-- | <i> O(n) </i>. Concatenate two lists
--   
--   Example: &gt; pconcat # psingleton x # psingleton y == plistLiteral
--   [x, y]
--   
--   pconcat exhibits identities with empty lists such that &gt; forall x.
--   pconcat # pnil # x == x &gt; forall x. pconcat # x # pnil == x
pconcat :: PIsListLike list a => Term s (list a :--> (list a :--> list a))

-- | <i> O(min(n, m)) </i>. Zip two lists together with a passed function.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzipWith :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => Term s ((a :--> (b :--> c)) :--> (list a :--> (list b :--> list c)))

-- | Like <a>pzipWith</a> but with Haskell-level merge function.
pzipWith' :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => (Term s a -> Term s b -> Term s c) -> Term s (list a :--> (list b :--> list c))

-- | <i> O(min(n, m)) </i>. Zip two lists together, creating pairs of the
--   elements.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzip :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list (PPair a b)) => Term s (list a :--> (list b :--> list (PPair a b)))

-- | <i> O(n) </i>. Map a function over a list of elements
pmap :: (PListLike list, PElemConstraint list a, PElemConstraint list b) => Term s ((a :--> b) :--> (list a :--> list b))

-- | <i> O(n) </i>. Filter elements from a list that don't match the
--   predicate.
pfilter :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> list a))

-- | <i> O(n) </i>. like haskell level <tt>find</tt> but on plutarch level
pfind :: PIsListLike l a => Term s ((a :--> PBool) :--> (l a :--> PMaybe a))

-- | Like <a>pelimList</a>, but with a fixpoint recursion hatch.
precList :: PIsListLike list a => (Term s (list a :--> r) -> Term s a -> Term s (list a) -> Term s r) -> (Term s (list a :--> r) -> Term s r) -> Term s (list a :--> r)

-- | <i> O(n) </i>. Fold on a list right-associatively.
pfoldr :: PIsListLike list a => Term s ((a :--> (b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list right-associatively, with opportunity
--   for short circuting.
--   
--   May short circuit when given reducer function is lazy in its second
--   argument.
pfoldrLazy :: PIsListLike list a => Term s ((a :--> (PDelayed b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list left-associatively.
pfoldl :: PIsListLike list a => Term s ((b :--> (a :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Check that predicate holds for all elements in a list.
pall :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check that predicate holds for any element in a list.
pany :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the plutarch
--   level
(#!!) :: PIsListLike l a => Term s (l a) -> Term s PInteger -> Term s a
data PList (a :: PType) (s :: S)
PSCons :: Term s a -> Term s (PList a) -> PList (a :: PType) (s :: S)
PSNil :: PList (a :: PType) (s :: S)

-- | Plutus Maybe type, with Scott-encoded repr
data PMaybe (a :: S -> Type) (s :: S)
PJust :: Term s a -> PMaybe (a :: S -> Type) (s :: S)
PNothing :: PMaybe (a :: S -> Type) (s :: S)

-- | Scott-encoded <a>Either</a>.
data PEither (a :: PType) (b :: PType) (s :: S)
PLeft :: Term s a -> PEither (a :: PType) (b :: PType) (s :: S)
PRight :: Term s b -> PEither (a :: PType) (b :: PType) (s :: S)

-- | Plutus encoding of Pairs.
--   
--   Note: This is represented differently than <tt>BuiltinPair</tt>. It is
--   scott-encoded.
data PPair (a :: PType) (b :: PType) (s :: S)
PPair :: Term s a -> Term s b -> PPair (a :: PType) (b :: PType) (s :: S)

-- | An Arbitrary Term with an unknown type
newtype POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque
data PData (s :: S)
pfstBuiltin :: Term s (PBuiltinPair a b :--> a)
psndBuiltin :: Term s (PBuiltinPair a b :--> b)

-- | Plutus <tt>BuiltinPair</tt>
data PBuiltinPair (a :: PType) (b :: PType) (s :: S)

-- | Plutus <tt>BuiltinList</tt>
data PBuiltinList (a :: PType) (s :: S)
PCons :: Term s a -> Term s (PBuiltinList a) -> PBuiltinList (a :: PType) (s :: S)
PNil :: PBuiltinList (a :: PType) (s :: S)

-- | Laws: - If <tt>PSubtype PData a</tt>, then <tt>pdataImpl a</tt> must
--   be <a>pupcast</a>. - pdataImpl . pupcast . pfromDataImpl ≡ id -
--   pfromDataImpl . punsafeDowncast . pdataImpl ≡ id
class PIsData a
pfromData :: PIsData a => Term s (PAsData a) -> Term s a
pdata :: PIsData a => Term s a -> Term s (PAsData a)
data PAsData (a :: PType) (s :: S)

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
data PDataSum defs s
data PLabeledType
(:=) :: Symbol -> PType -> PLabeledType

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label ':= a) ': l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name b p s a as n. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)

-- | Selector function to extract the field from the record.
getField :: HasField x r a => r -> a

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b
class PShow t

-- | Return the string representation of a Plutarch value
pshow :: PShow a => Term s a -> Term s PString

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Trace the given message at the debug level before evaluating the given
--   argument.
ptraceDebug :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the info
--   level.
ptraceInfoShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Trace the given message at the info level if the argument is false.
ptraceInfoIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the info level if the argument is true.
ptraceInfoIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the info level, then terminate with
--   <a>perror</a>.
ptraceInfoError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the debug
--   level.
ptraceDebugShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Trace the given message at the debug level if the argument is false.
ptraceDebugIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level if the argument is true.
ptraceDebugIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level, then terminate with
--   <a>perror</a>.
ptraceDebugError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Backward compatibility synonym for <a>ptraceInfo</a>.

-- | <i>Deprecated: Use ptraceInfo</i>
ptrace :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Synonym for <a>ptraceInfoShowId</a>.

-- | <i>Deprecated: Use ptraceInfoShowId</i>
ptraceShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Synonym for <a>ptraceInfoError</a>.

-- | <i>Deprecated: Use ptraceInfoError</i>
ptraceError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Synonym for <a>ptraceInfoIfFalse</a>.

-- | <i>Deprecated: Use ptraceInfoIfFalse</i>
ptraceIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Synonym for <a>ptraceInfoIfTrue</a>.

-- | <i>Deprecated: Use ptraceInfoIfTrue</i>
ptraceIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Hash a <a>PByteString</a> using SHA-256.
psha2_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using SHA3-256.
psha3_256 :: Term s (PByteString :--> PByteString)

-- | Verify the signature against the public key and message.

-- | <i>Deprecated: use one of the Ed25519, Schnorr- or ECDSA Secp256k1
--   signature verification functions</i>
pverifySignature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Create a Plutarch-level constant, from a Haskell value. Example: &gt;
--   pconstant @PInteger 42
pconstant :: forall p s. PLift p => PLifted p -> Term s p

-- | Create a Plutarch-level <a>PAsData</a> constant, from a Haskell value.
--   Example: &gt; pconstantData @PInteger 42
pconstantData :: forall p h s. (ToData h, PLifted p ~ h, PConstanted h ~ p) => h -> Term s (PAsData p)

-- | Like <a>plift'</a> but throws on failure.
plift :: forall p. (HasCallStack, PLift p) => ClosedTerm p -> PLifted p

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaNewtype</tt>.
--   
--   A newtype <tt>Foo a</tt> is considered <a>Constantable</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
type PConstant a = (a ~ PLifted (PConstanted a), PConstantDecl a)

-- | Class of Plutarch types <tt>p</tt> that can be converted to/from a
--   Haskell type.
--   
--   The Haskell type is determined by `PLifted p`.
--   
--   This typeclass is closely tied with <a>PConstant</a>.
type PLift = PUnsafeLiftDecl

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaData</tt>.
--   
--   A type <tt>Foo a</tt> is considered <a>ConstantableData</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   <li>The newtype has <tt>FromData</tt> and <tt>ToData</tt>
--   instances</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   data Bar a = Bar a deriving stock (GHC.Generic)
--   
--   PlutusTx.makeLift ''Bar
--   PlutusTx.makeIsDataIndexed ''Bar [('Bar, 0)]
--   
--   data PBar (a :: PType) (s :: S)
--     = PBar (Term s (PDataRecord '["_0" ':= a]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (SOP.Generic, PIsDataRepr)
--     deriving (PlutusType, PIsData, PDataFields) via PIsDataReprInstances (PBar a)
--   
--   instance
--     forall a.
--     PLiftData a =&gt;
--     PUnsafeLiftDecl (PBar a)
--     where
--     type PLifted (PBar a) = Bar (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaData
--         (Bar a)
--         (PBar (PConstanted a))
--     )
--     instance
--       PConstantData a =&gt;
--       PConstantDecl (Bar a)
--   </pre>
type PConstantData h = (PConstant h, FromData h, ToData h, PIsData (PConstanted h))
type PLiftData p = (PLift p, FromData (PLifted p), ToData (PLifted p), PIsData p)
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Like <a>plet</a> but works in a <a>TermCont</a> monad
pletC :: Term s a -> TermCont s (Term s a)

-- | Like <a>pmatch</a> but works in a <a>TermCont</a> monad
pmatchC :: PlutusType a => Term s a -> TermCont s (a s)

-- | Like <a>pletFields</a> but works in a <a>TermCont</a> monad.
pletFieldsC :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> TermCont @b s (HRec (BoundTerms ps bs s))

-- | Like <tt>ptrace</tt> but works in a <a>TermCont</a> monad.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   foo :: Term s PUnit
--   foo = unTermCont $ do
--     ptraceC "returning unit!"
--     pure $ pconstant ()
--   </pre>
ptraceC :: Term s PString -> TermCont s ()

-- | Trace a message and raise error if <tt>cond</tt> is false. Otherwise,
--   continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   onlyAllow42 :: Term s (PInteger :--&gt; PUnit)
--   onlyAllow42 = plam $ i -&gt; unTermCont $ do
--     pguardC "expected 42" $ i #== 42
--     pure $ pconstant ()
--   </pre>
pguardC :: Term s PString -> Term s PBool -> TermCont s ()

-- | Stop computation and return given term if <tt>cond</tt> is false.
--   Otherwise, continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   is42 :: Term s (PInteger :--&gt; PBool)
--   is42 = plam $ i -&gt; unTermCont $ do
--     pguardC' (pconstant False) $ i #== 42
--     pure $ pconstant True
--   </pre>
pguardC' :: Term s a -> Term s PBool -> TermCont @a s ()

-- | <a>TermCont</a> producing version of <a>ptryFrom</a>.
ptryFromC :: forall b r a s. PTryFrom a b => Term s a -> TermCont @r s (Term s b, Reduce (PTryFromExcess a b s))
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a
ptryFrom :: forall b a s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r

-- | <tt>PTryFrom a b</tt> represents a subtyping relationship between
--   <tt>a</tt> and <tt>b</tt>, and a way to go from <tt>a</tt> to
--   <tt>b</tt>. Laws: - <tt>(punsafeCoerce . fst) <a>$</a> tcont (ptryFrom
--   x) ≡ pure x</tt>
class PSubtype a b => PTryFrom (a :: PType) (b :: PType)
type family PSubtype (a :: PType) (b :: PType) :: Constraint

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class () => Generic a

module Plutarch.Monadic

-- | Bind function used within do syntax.
--   
--   Enables elegant usage of <a>pmatch</a> and similar. <tt>P.do { y &lt;-
--   x ; z }</tt> is equivalent to <tt>x $ y -&gt; z</tt>.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   f :: Term s (PTxInfo :--&gt; PBuiltinList (PAsData PTxInInfo))
--   f = plam $ x -&gt; P.do
--     PTxInfo txInfoFields &lt;- pmatch x
--     pfromData $ pdhead # txInfoFields
--   </pre>
(>>=) :: (x -> Term s a) -> x -> Term s a

-- | Forgetful bind function used within do syntax.
--   
--   Enables elegant usage of <a>ptrace</a> and similar. <tt>P.do { x ; y
--   }</tt> is equivalent to <tt>x y</tt>.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   P.do
--     ptrace "yielding unit"
--     pconstant ()
--   </pre>
(>>) :: (x -> Term s a) -> x -> Term s a

-- | Implicitly invoked upon pattern match failure within do syntax.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   P.do
--     -- calls <a>fail</a>, traces an error message, and invokes <a>perror</a>.
--     PTrue &lt;- pconstant False
--   </pre>
fail :: String -> Term s a

module Plutarch.BitString

-- | A wrapper around <a>PByteString</a> for CIP-122 and CIP-123 bitwise
--   operations.
--   
--   <h1>Note</h1>
--   
--   This type exists because <i>bit</i> and <i>byte</i> indexes work in
--   different directions. To avoid confusing behaviour, we require an
--   explicit wrapping of <a>PByteString</a>s to use bitwise functionality:
--   this way, it's clear where which scheme applies.
--   
--   @since WIP
newtype PBitString (s :: S)
PBitString :: Term s PByteString -> PBitString (s :: S)

-- | Bit access operation, as defined in <a>CIP-122</a>.
--   
--   @since WIP
preadBit :: forall (s :: S). Term s (PBitString :--> (PInteger :--> PBool))

-- | Given a list of positions, set the bits at those positions.
--   
--   This works similarly to the <tt>writeBits</tt> operation in
--   <a>CIP-122</a> with regard to the list of indexes. Effectively,
--   <tt>psetBits b ixes</tt> is equivalent to <tt>writeBits b . map (,
--   True) $ ixes</tt>. All caveats that this entails from the CIP-122
--   description apply.
--   
--   @since WIP
--   
--   Sets bits, as per <a>CIP-122</a>.
--   
--   @since WIP
pwriteBits :: forall (s :: S). Term s (PBitString :--> (PBuiltinList PInteger :--> (PBool :--> PBitString)))

-- | Performs a shift, as per <a>CIP-123</a>.
--   
--   @since WIP
pshift :: forall (s :: S). Term s (PBitString :--> (PInteger :--> PBitString))

-- | Performs a rotation, as per <a>CIP-123</a>.
--   
--   @since WIP
protate :: forall (s :: S). Term s (PBitString :--> (PInteger :--> PBitString))

-- | Counts the number of set bits, as per <a>CIP-123</a>.
--   
--   @since WIP
pcountSetBits :: forall (s :: S). Term s (PBitString :--> PInteger)

-- | As <tt>pfindFirstSetBit'</tt>, but produces <a>PNothing</a> if the
--   argument is empty, or contains no set bits.
--   
--   @since WIP
pfindFirstSetBit :: forall (s :: S). Term s (PBitString :--> PMaybe PInteger)

-- | Finds the index of the first set bit, as per <a>CIP-123</a>.
--   
--   <h1>Note</h1>
--   
--   This returns <tt>-1</tt> if the argument is either empty, or contains
--   no set bits.
--   
--   @since WIP
pfindFirstSetBit' :: forall (s :: S). Term s (PBitString :--> PInteger)
instance Plutarch.Bool.POrd Plutarch.BitString.PBitString
instance Plutarch.Bool.PPartialOrd Plutarch.BitString.PBitString
instance Plutarch.Bool.PEq Plutarch.BitString.PBitString
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.BitString.PBitString
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.BitString.PBitString s)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.BitString.PBitString

module Plutarch.BLS

-- | A point on the BLS12-381 G1 curve.
newtype PBuiltinBLS12_381_G1_Element s
PBuiltinBLS12_381_G1_Element :: Term s POpaque -> PBuiltinBLS12_381_G1_Element s

-- | Add two points on the BLS12-381 G1 curve.
pbls12_381_G1_add :: Term s (PBuiltinBLS12_381_G1_Element :--> (PBuiltinBLS12_381_G1_Element :--> PBuiltinBLS12_381_G1_Element))

-- | Multiply a point on the BLS12-381 G1 curve by a scalar.
pbls12_381_G1_scalarMul :: Term s (PInteger :--> (PBuiltinBLS12_381_G1_Element :--> PBuiltinBLS12_381_G1_Element))

-- | Negate a point on the BLS12-381 G1 curve.
pbls12_381_G1_neg :: Term s (PBuiltinBLS12_381_G1_Element :--> PBuiltinBLS12_381_G1_Element)

-- | Compress a point on the BLS12-381 G1 curve to a byte string.
pbls12_381_G1_compress :: Term s (PBuiltinBLS12_381_G1_Element :--> PByteString)

-- | Uncompress a byte string to a point on the BLS12-381 G1 curve.
pbls12_381_G1_uncompress :: Term s (PByteString :--> PBuiltinBLS12_381_G1_Element)

-- | Hash a message to a point on the BLS12-381 G1 curve.
pbls12_381_G1_hashToGroup :: Term s (PByteString :--> (PByteString :--> PBuiltinBLS12_381_G1_Element))

-- | The compressed representation of the zero point on the BLS12-381 G1
--   curve.
pbls12_381_G1_compressed_zero :: Term s PByteString

-- | The compressed representation of the generator point on the BLS12-381
--   G1 curve.
pbls12_381_G1_compressed_generator :: Term s PByteString

newtype PBuiltinBLS12_381_G2_Element s
PBuiltinBLS12_381_G2_Element :: Term s POpaque -> PBuiltinBLS12_381_G2_Element s

-- | Add two points on the BLS12-381 G2 curve.
pbls12_381_G2_add :: Term s (PBuiltinBLS12_381_G2_Element :--> (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_G2_Element))

-- | Multiply a point on the BLS12-381 G2 curve by a scalar.
pbls12_381_G2_scalarMul :: Term s (PInteger :--> (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_G2_Element))

-- | Negate a point on the BLS12-381 G2 curve.
pbls12_381_G2_neg :: Term s (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_G2_Element)

-- | Compress a point on the BLS12-381 G2 curve to a byte string.
pbls12_381_G2_compress :: Term s (PBuiltinBLS12_381_G2_Element :--> PByteString)

-- | Uncompress a byte string to a point on the BLS12-381 G2 curve.
pbls12_381_G2_uncompress :: Term s (PByteString :--> PBuiltinBLS12_381_G2_Element)

-- | Hash a message to a point on the BLS12-381 G2 curve.
pbls12_381_G2_hashToGroup :: Term s (PByteString :--> (PByteString :--> PBuiltinBLS12_381_G2_Element))

-- | The compressed representation of the zero point on the BLS12-381 G2
--   curve.
pbls12_381_G2_compressed_zero :: Term s PByteString

-- | The compressed representation of the generator point on the BLS12-381
--   G2 curve.
pbls12_381_G2_compressed_generator :: Term s PByteString

-- | Represents the result of a Miller loop operation in BLS12-381 pairing.
newtype PBuiltinBLS12_381_MlResult s
PBuiltinBLS12_381_MlResult :: Term s POpaque -> PBuiltinBLS12_381_MlResult s

-- | Perform a Miller loop operation on a G1 and G2 element.
pbls12_381_millerLoop :: Term s (PBuiltinBLS12_381_G1_Element :--> (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_MlResult))

-- | Multiply two Miller loop results.
pbls12_381_mulMlResult :: Term s (PBuiltinBLS12_381_MlResult :--> (PBuiltinBLS12_381_MlResult :--> PBuiltinBLS12_381_MlResult))

-- | Perform the final verification step in BLS12-381 pairing.
pbls12_381_finalVerify :: Term s (PBuiltinBLS12_381_MlResult :--> (PBuiltinBLS12_381_MlResult :--> PBool))
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.BLS.PBuiltinBLS12_381_G1_Element
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.BLS.PBuiltinBLS12_381_G1_Element s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.BLS.PBuiltinBLS12_381_G2_Element
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.BLS.PBuiltinBLS12_381_G2_Element s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.BLS.PBuiltinBLS12_381_MlResult
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.BLS.PBuiltinBLS12_381_MlResult s)
instance Plutarch.Lift.PConstantDecl PlutusCore.Crypto.BLS12_381.G1.Element
instance Plutarch.Lift.PConstantDecl PlutusCore.Crypto.BLS12_381.G2.Element
instance Plutarch.Lift.PConstantDecl PlutusCore.Crypto.BLS12_381.Pairing.MlResult
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.BLS.PBuiltinBLS12_381_MlResult
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.BLS.PBuiltinBLS12_381_MlResult
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Bool.PEq Plutarch.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Bool.PEq Plutarch.BLS.PBuiltinBLS12_381_G1_Element
