-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch-testlib
@version 1.0.0


-- | Utilities for golden testing
--   
--   To regenerate golden tests it is enough to remove <tt>./goldens</tt>
--   directory and rerun tests
module Plutarch.Test.Golden

-- | Opaque type representing tree of golden tests
--   
--   @since WIP
data GoldenTestTree

-- | Convert tree of golden tests into standard Tasty <a>TestTree</a>,
--   capturing results produced by nested golden tests
--   
--   @since WIP
plutarchGolden :: TestName -> FilePath -> [GoldenTestTree] -> TestTree

-- | Like <a>testGroup</a> but for golden tests
--   
--   Goldens in the group will be prefixed by the group name
--   
--   @since WIP
goldenGroup :: TestName -> [GoldenTestTree] -> GoldenTestTree

-- | Like <a>testEval</a> but will append to goldens created by enclosing
--   <a>plutarchGolden</a>
--   
--   @since WIP
goldenEval :: TestName -> ClosedTerm a -> GoldenTestTree

-- | Like <a>testEvalFail</a> but will append to goldens created by
--   enclosing <a>plutarchGolden</a>
--   
--   @since WIP
goldenEvalFail :: TestName -> ClosedTerm a -> GoldenTestTree
instance GHC.Show.Show Plutarch.Test.Golden.Benchmark
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Test.Golden.PerfBenchmark


-- | Dummy types used in tests
module Plutarch.Test.SpecTypes

-- | Tuple of three elements of the same type
--   
--   @since WIP
data Triplet a
Triplet :: a -> a -> a -> Triplet a

-- | We can defined a data-type using PDataRecord, with labeled fields.
--   
--   With an appropriate instance of <tt>PIsDataRepr</tt>, we can
--   automatically derive <a>PDataFields</a>.
--   
--   @since WIP
newtype PTriplet (a :: PType) (s :: S)
PTriplet :: Term s (PDataRecord '["x" ':= a, "y" ':= a, "z" ':= a]) -> PTriplet (a :: PType) (s :: S)
instance forall a. Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutarch.Test.SpecTypes.Triplet a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Test.SpecTypes.PTriplet a)
instance forall a. Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. GHC.Show.Show a => GHC.Show.Show (Plutarch.Test.SpecTypes.Triplet a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.POrd (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.PPartialOrd (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Test.SpecTypes.PTriplet a s)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Test.SpecTypes.PTriplet a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutarch.Test.SpecTypes.Triplet a)


-- | Utilities for unit testing plutarch terms
module Plutarch.Test.Unit

-- | Assert that term failed to compile
--   
--   @since WIP
testCompileFail :: TestName -> ClosedTerm a -> TestTree

-- | Assert that term compiled and evaluated without errors
--   
--   @since WIP
testEval :: TestName -> ClosedTerm a -> TestTree

-- | Assert that term compiled correctly but evaluated with errors
--   
--   @since WIP
testEvalFail :: TestName -> ClosedTerm a -> TestTree

-- | Assert that term compiled and evaluated without errors and matches the
--   expected value note that comparison is done on AST level, not by
--   <a>Eq</a> or <a>PEq</a>
--   
--   @since WIP
testEvalEqual :: TestName -> ClosedTerm a -> ClosedTerm a -> TestTree

-- | Assert that term compiled (with specified tracing level and
--   <a>DetTracing</a>) and evaluated without errors produced traces that
--   match expected value. Note that this succeeds even if script evaluated
--   to error if traces still match
--   
--   @since WIP
testEvalEqualTraces :: TestName -> ClosedTerm a -> LogLevel -> [Text] -> TestTree

-- | @since WIP
data TermResult
FailedToCompile :: Text -> TermResult
FailedToEvaluate :: EvalError -> [Text] -> TermResult
Evaluated :: String -> [Text] -> TermResult

-- | @since WIP
evalTermResult :: Config -> ClosedTerm a -> TermResult

module Plutarch.Test.Utils

-- | Decrease number of quickcheck tests by specified factor
fewerTests :: QuickCheckTests -> QuickCheckTests -> QuickCheckTests
prettyShow :: forall (a :: Type). Pretty a => a -> String
prettyEquals :: (Eq a, Pretty a) => a -> a -> Property
typeName :: forall k (a :: k). Typeable a => String
instanceOfType :: forall k (a :: k). Typeable a => String -> String
typeName' :: Bool -> TypeRep k -> String

module Plutarch.Test.QuickCheck

-- | Like <a>testEval</a> but generate terms
--   
--   @since WIP
propEval :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> TestTree

-- | Like <a>testEvalFail</a> but generate terms
--   
--   @since WIP
propEvalFail :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> TestTree

-- | Like <a>testCompileFail</a> but generate terms
--   
--   @since WIP
propCompileFail :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> TestTree

-- | Like <a>testEvalEqual</a> but generate terms
--   
--   @since WIP
propEvalEqual :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> (a -> ClosedTerm b) -> TestTree

-- | @since WIP
checkHaskellEquivalent :: forall (plutarchInput :: S -> Type) (plutarchOutput :: S -> Type). (PUnsafeLiftDecl plutarchInput, Pretty (PLifted plutarchInput), Arbitrary (PLifted plutarchInput), PUnsafeLiftDecl plutarchOutput, Pretty (PLifted plutarchOutput), Eq (PLifted plutarchOutput)) => (PLifted plutarchInput -> PLifted plutarchOutput) -> ClosedTerm (plutarchInput :--> plutarchOutput) -> Property

-- | @since WIP
checkHaskellEquivalent2 :: forall (plutarchInput1 :: S -> Type) (plutarchInput2 :: S -> Type) (plutarchOutput :: S -> Type). (PUnsafeLiftDecl plutarchInput1, Pretty (PLifted plutarchInput1), Arbitrary (PLifted plutarchInput1), PUnsafeLiftDecl plutarchInput2, Pretty (PLifted plutarchInput2), Arbitrary (PLifted plutarchInput2), PUnsafeLiftDecl plutarchOutput, Pretty (PLifted plutarchOutput), Eq (PLifted plutarchOutput)) => (PLifted plutarchInput1 -> PLifted plutarchInput2 -> PLifted plutarchOutput) -> ClosedTerm (plutarchInput1 :--> (plutarchInput2 :--> plutarchOutput)) -> Property
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.Positive a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.Negative a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.NonZero a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.NonNegative a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.NonPositive a)

module Plutarch.Test.Laws

-- | Like <a>checkLedgerProperties</a> but specialized to <tt>PValue</tt>
--   
--   This is an ugly kludge because PValue doesn't have a direct PData
--   conversion, and bringing one in would break too much other stuff to be
--   worth it.
--   
--   @since WIP
checkLedgerPropertiesValue :: TestTree

-- | Like <a>checkLedgerProperties</a> but specialized to <tt>PMap</tt>
--   
--   Same as above
--   
--   @since WIP
checkLedgerPropertiesAssocMap :: TestTree

-- | @since WIP
checkLedgerProperties :: forall (a :: S -> Type). (Typeable a, PUnsafeLiftDecl a, PTryFrom PData a, Eq (PLifted a), Show (PLifted a), Arbitrary (PLifted a), PIsData a, ToData (PLifted a), Typeable (PLifted a), Pretty (PLifted a)) => TestTree

-- | @since WIP
checkLedgerPropertiesPCountable :: forall (a :: S -> Type). (Typeable a, PCountable a, Arbitrary (PLifted a), Pretty (PLifted a), Eq (PLifted a), Show (PLifted a), PUnsafeLiftDecl a) => TestTree

-- | @since WIP
checkLedgerPropertiesPEnumerable :: forall (a :: S -> Type). (Typeable a, PEnumerable a, Arbitrary (PLifted a), Pretty (PLifted a), Eq (PLifted a), Show (PLifted a), PUnsafeLiftDecl a) => TestTree

-- | @since WIP
checkHaskellOrdEquivalent :: forall (plutarchInput :: S -> Type). (PUnsafeLiftDecl plutarchInput, Pretty (PLifted plutarchInput), Arbitrary (PLifted plutarchInput), Typeable (PLifted plutarchInput), Ord (PLifted plutarchInput), Typeable plutarchInput, PPartialOrd plutarchInput) => TestTree
checkHaskellNumEquivalent :: forall (plutarchInput :: S -> Type). (PUnsafeLiftDecl plutarchInput, Pretty (PLifted plutarchInput), Arbitrary (PLifted plutarchInput), Eq (PLifted plutarchInput), Typeable (PLifted plutarchInput), Num (PLifted plutarchInput), Typeable plutarchInput, PNum plutarchInput) => TestTree

-- | @since WIP
checkHaskellIntegralEquivalent :: forall (plutarchInput :: S -> Type). (PUnsafeLiftDecl plutarchInput, Pretty (PLifted plutarchInput), Arbitrary (PLifted plutarchInput), Typeable (PLifted plutarchInput), Integral (PLifted plutarchInput), Typeable plutarchInput, PIntegral plutarchInput) => TestTree
