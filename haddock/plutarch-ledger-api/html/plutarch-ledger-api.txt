-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch-ledger-api
@version 3.2.1


-- | This module is meant to be imported qualified, as some of its
--   identifiers clash with the Plutarch prelude, as well as other parts of
--   the Plutarch API.
module Plutarch.LedgerApi.Interval

newtype PInterval (a :: S -> Type) (s :: S)
PInterval :: Term s (PDataRecord '["from" ':= PLowerBound a, "to" ':= PUpperBound a]) -> PInterval (a :: S -> Type) (s :: S)

newtype PLowerBound (a :: S -> Type) (s :: S)
PLowerBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PBool]) -> PLowerBound (a :: S -> Type) (s :: S)

newtype PUpperBound (a :: S -> Type) (s :: S)
PUpperBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PBool]) -> PUpperBound (a :: S -> Type) (s :: S)

data PExtended (a :: S -> Type) (s :: S)
PNegInf :: Term s (PDataRecord '[]) -> PExtended (a :: S -> Type) (s :: S)
PFinite :: Term s (PDataRecord '["_0" ':= a]) -> PExtended (a :: S -> Type) (s :: S)
PPosInf :: Term s (PDataRecord '[]) -> PExtended (a :: S -> Type) (s :: S)

-- | Given <tt>x</tt>, create the interval <tt>[x, x]</tt>.
psingleton :: forall (a :: S -> Type) (s :: S). Term s (PAsData a :--> PInterval a)

-- | Given <tt>x</tt>, create the interval <tt>[x, +infty)</tt>
pfrom :: forall (a :: S -> Type) (s :: S). Term s (PAsData a :--> PInterval a)

-- | Given <tt>x</tt>, create the interval <tt>(-infty, x]</tt>.
pto :: forall (a :: S -> Type) (s :: S). Term s (PAsData a :--> PInterval a)

-- | Create the interval <tt>(-infty, +infty)</tt>.
palways :: forall (a :: S -> Type) (s :: S). PLiftData a => Term s (PInterval a)

-- | <tt><a>pinterval</a> x y</tt> creates the interval <tt>[x, y]</tt>.
pinterval :: forall (a :: S -> Type) (s :: S). Term s (PAsData a :--> (PAsData a :--> PInterval a))

-- | Turn a <a>PLowerBound</a> into a single inclusive bounding value.
--   
--   @since WIP
pinclusiveLowerBound :: forall (a :: S -> Type) (s :: S). (PIsData a, PCountable a) => Term s (PLowerBound a :--> PExtended a)

-- | Turn a <a>PUpperBound</a> into a single inclusive bounding value.
--   
--   @since WIP
pinclusiveUpperBound :: forall (a :: S -> Type) (s :: S). (PIsData a, PEnumerable a) => Term s (PUpperBound a :--> PExtended a)

-- | Check if a value is inside the given interval.
--   
--   @since WIP
pmember :: forall (a :: S -> Type) (s :: S). (PIsData a, PEnumerable a) => Term s (PAsData a :--> (PInterval a :--> PBool))

-- | <tt><a>pcontains</a> # i1 # i2</tt> is true if <tt>i2</tt> is entirely
--   contained in <tt>i1</tt>: more specifically, if for any <tt>s</tt>, if
--   <tt><a>pmember</a> # s # i2</tt>, then <tt><a>pmember</a> # s #
--   i1</tt>.
--   
--   @since WIP
pcontains :: forall (a :: S -> Type) (s :: S). (PIsData a, PEnumerable a) => Term s (PInterval a :--> (PInterval a :--> PBool))

-- | <tt><tt>before</tt> x i</tt> is true if <tt>x</tt> is earlier than the
--   start of <tt>i</tt>.
pbefore :: forall (a :: S -> Type) (s :: S). (POrd a, PIsData a) => Term s (a :--> (PInterval a :--> PBool))

-- | <tt><tt>after</tt> x u</tt> is true if <tt>x</tt> is later than the
--   end of <tt>i</tt>.
pafter :: forall (a :: S -> Type) (s :: S). (POrd a, PIsData a) => Term s (a :--> (PInterval a :--> PBool))

-- | Check if a <a>PInterval</a> is empty.
--   
--   @since WIP
pisEmpty :: forall (a :: S -> Type) (s :: S). (PIsData a, PEnumerable a) => Term s (PInterval a :--> PBool)

-- | <tt><a>phull</a> i1 i2</tt> gives the smallest interval that contains
--   both <tt>i1</tt> and <tt>i2</tt>.
phull :: forall (a :: S -> Type) (s :: S). (POrd a, PIsData a) => Term s (PInterval a :--> (PInterval a :--> PInterval a))

-- | <tt><a>pintersection</a> i1 i2</tt> gives the largest interval that is
--   contained in both <tt>i1</tt> and <tt>i2</tt>.
pintersection :: forall (a :: S -> Type) (s :: S). (POrd a, PIsData a) => Term s (PInterval a :--> (PInterval a :--> PInterval a))
instance (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.LedgerApi.Interval.PExtended a)
instance (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.POrd (Plutarch.LedgerApi.Interval.PExtended a)
instance (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.PPartialOrd (Plutarch.LedgerApi.Interval.PExtended a)
instance Plutarch.Bool.PEq (Plutarch.LedgerApi.Interval.PExtended a)
instance Plutarch.Builtin.PIsData (Plutarch.LedgerApi.Interval.PExtended a)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Interval.PExtended a)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Interval.PExtended a s)
instance (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.LedgerApi.Interval.PUpperBound a)
instance (Plutarch.Builtin.PIsData a, Plutarch.Enum.PEnumerable a) => Plutarch.Bool.POrd (Plutarch.LedgerApi.Interval.PUpperBound a)
instance Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.LedgerApi.Interval.PUpperBound a)
instance Plutarch.Builtin.PIsData (Plutarch.LedgerApi.Interval.PUpperBound a)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Interval.PUpperBound a)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Interval.PUpperBound a s)
instance (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.LedgerApi.Interval.PLowerBound a)
instance (Plutarch.Builtin.PIsData a, Plutarch.Enum.PCountable a) => Plutarch.Bool.POrd (Plutarch.LedgerApi.Interval.PLowerBound a)
instance Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.LedgerApi.Interval.PLowerBound a)
instance Plutarch.Builtin.PIsData (Plutarch.LedgerApi.Interval.PLowerBound a)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Interval.PLowerBound a)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Interval.PLowerBound a s)
instance (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.LedgerApi.Interval.PInterval a)
instance (Plutarch.Builtin.PIsData a, Plutarch.Enum.PEnumerable a) => Plutarch.Bool.POrd (Plutarch.LedgerApi.Interval.PInterval a)
instance (Plutarch.Builtin.PIsData a, Plutarch.Enum.PEnumerable a) => Plutarch.Bool.PPartialOrd (Plutarch.LedgerApi.Interval.PInterval a)
instance Plutarch.Bool.PEq (Plutarch.LedgerApi.Interval.PInterval a)
instance Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.LedgerApi.Interval.PInterval a)
instance Plutarch.Builtin.PIsData (Plutarch.LedgerApi.Interval.PInterval a)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Interval.PInterval a)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Interval.PInterval a s)
instance Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (PlutusLedgerApi.V1.Interval.Interval a)
instance Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (PlutusLedgerApi.V1.Interval.LowerBound a)
instance Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (PlutusLedgerApi.V1.Interval.UpperBound a)
instance Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (PlutusLedgerApi.V1.Interval.Extended a)
instance Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.LedgerApi.Interval.PInterval a)
instance Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.LedgerApi.Interval.PInterval a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.LedgerApi.Interval.PInterval a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Interval.PInterval a))
instance (Plutarch.Builtin.PIsData a, Plutarch.Enum.PCountable a) => Plutarch.Bool.PEq (Plutarch.LedgerApi.Interval.PLowerBound a)
instance (Plutarch.Builtin.PIsData a, Plutarch.Enum.PCountable a) => Plutarch.Bool.PPartialOrd (Plutarch.LedgerApi.Interval.PLowerBound a)
instance Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.LedgerApi.Interval.PLowerBound a)
instance Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.LedgerApi.Interval.PLowerBound a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.LedgerApi.Interval.PLowerBound a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Interval.PLowerBound a))
instance (Plutarch.Builtin.PIsData a, Plutarch.Enum.PEnumerable a) => Plutarch.Bool.PEq (Plutarch.LedgerApi.Interval.PUpperBound a)
instance (Plutarch.Builtin.PIsData a, Plutarch.Enum.PEnumerable a) => Plutarch.Bool.PPartialOrd (Plutarch.LedgerApi.Interval.PUpperBound a)
instance Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.LedgerApi.Interval.PUpperBound a)
instance Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.LedgerApi.Interval.PUpperBound a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.LedgerApi.Interval.PUpperBound a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Interval.PUpperBound a))
instance Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.LedgerApi.Interval.PExtended a)
instance Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.LedgerApi.Interval.PExtended a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.LedgerApi.Interval.PExtended a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Interval.PExtended a))


-- | Useful tools that aren't part of the Plutarch API per se, but get used
--   in multiple places.
module Plutarch.LedgerApi.Utils

-- | <a>Term</a>, but with its type arguments flipped. This is a useful
--   helper for defining <a>PTryFrom</a> instances.
--   
--   For example, consider the <a>PTryFrom</a> instance for
--   <tt>PTokenName</tt>:
--   
--   <pre>
--   instance PTryFrom PData (PAsData PTokenName) where
--      type PTryFromExcess PData (PAsData PTokenName) = Mret PTokenName
--   </pre>
--   
--   We need to do this because <a>PTryFromExcess</a> expects something of
--   kind <tt>S -&gt; Type</tt>, but <a>Term</a> has kind <tt>S -&gt; (S
--   -&gt; Type) -&gt; Type</tt>, which doesn't quite fit. By using
--   <a>Mret</a>, we end up with something of kind <tt>(S -&gt; Type) -&gt;
--   S -&gt; Type</tt>, which fits.
--   
--   The name is just <a>Term</a> written backwards.
newtype Mret (a :: S -> Type) (s :: S)
Mret :: Term s a -> Mret (a :: S -> Type) (s :: S)

-- | @since WIP
data PMaybeData (a :: S -> Type) (s :: S)
PDJust :: Term s (PAsData a) -> PMaybeData (a :: S -> Type) (s :: S)
PDNothing :: PMaybeData (a :: S -> Type) (s :: S)

-- | A Rational type that corresponds to the data encoding used by
--   <a>Rational</a>.
newtype PRationalData s
PRationalData :: Term s (PDataRecord '["numerator" ':= PInteger, "denominator" ':= PPositive]) -> PRationalData s

-- | Extracts the element out of a <a>PDJust</a> and throws an error if its
--   argument is <a>PDNothing</a>.
pfromDJust :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybeData a :--> a)

-- | Yield <a>PTrue</a> if a given <a>PMaybeData</a> is of the form
--   <tt><a>PDJust</a> _</tt>.
pisDJust :: forall (a :: PType) (s :: S). Term s (PMaybeData a :--> PBool)

-- | Special version of <tt>pmaybe</tt> that works with <a>PMaybeData</a>.
pmaybeData :: forall (a :: PType) (b :: PType) (s :: S). PIsData a => Term s (b :--> ((a :--> b) :--> (PMaybeData a :--> b)))

-- | Construct a <a>PDJust</a> value.
pdjust :: forall (a :: PType) (s :: S). PIsData a => Term s (a :--> PMaybeData a)

-- | Construct a <a>PDNothing</a> value.
pdnothing :: forall (a :: PType) (s :: S). Term s (PMaybeData a)

-- | Construct a <a>PMaybeData</a> given a <a>PMaybe</a>. Could be useful
--   if you want to "lift" from <a>PMaybe</a> to <a>Maybe</a>.
pmaybeToMaybeData :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybe a :--> PMaybeData a)

-- | Inverse of <a>pmaybeToMaybeData</a>
--   
--   @since WIP
pmaybeDataToMaybe :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybeData a :--> PMaybe a)

-- | Extract the value stored in a <a>PMaybeData</a> container. If there's
--   no value, throw an error with the given message.
passertPDJust :: forall (a :: PType) (s :: S). PIsData a => Term s (PString :--> (PMaybeData a :--> a))

prationalFromData :: ClosedTerm (PRationalData :--> PRational)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Utils.Mret a s)
instance (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.LedgerApi.Utils.PMaybeData a)
instance Plutarch.Bool.PEq (Plutarch.LedgerApi.Utils.PMaybeData a)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Utils.PMaybeData a s)
instance Plutarch.Show.PShow Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Bool.PEq Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Utils.PRationalData
instance GHC.Generics.Generic (Plutarch.LedgerApi.Utils.PRationalData s)
instance Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (GHC.Maybe.Maybe a)
instance Plutarch.Lift.PConstantDecl PlutusTx.Ratio.Rational
instance Plutarch.Bool.PPartialOrd Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Bool.POrd Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.Utils.PRationalData)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Utils.PMaybeData a)
instance Plutarch.Builtin.PIsData (Plutarch.LedgerApi.Utils.PMaybeData a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.LedgerApi.Utils.PMaybeData a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Utils.PMaybeData a))
instance Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.LedgerApi.Utils.PMaybeData a)
instance (Plutarch.Builtin.PIsData a, Plutarch.Bool.PPartialOrd a) => Plutarch.Bool.PPartialOrd (Plutarch.LedgerApi.Utils.PMaybeData a)
instance (Plutarch.Builtin.PIsData a, Plutarch.Bool.PPartialOrd a) => Plutarch.Bool.POrd (Plutarch.LedgerApi.Utils.PMaybeData a)


-- | This module is designed to be imported qualified, as many of its
--   identifiers clash with the Plutarch prelude.
module Plutarch.LedgerApi.AssocMap

newtype PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)

data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees

data Commutativity
Commutative :: Commutativity
NonCommutative :: Commutativity

-- | Construct an empty <a>PMap</a>.
pempty :: Term s (PMap 'Sorted k v)

-- | Construct a singleton <a>PMap</a> with the given key and value.
psingleton :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (PIsData k, PIsData v) => Term s (k :--> (v :--> PMap 'Sorted k v))

-- | Construct a singleton <a>PMap</a> with the given data-encoded key and
--   value.
psingletonData :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). Term s (PAsData k :--> (PAsData v :--> PMap 'Sorted k v))

punsortedMapFromFoldable :: forall (k :: PType) (v :: PType) (f :: Type -> Type) (s :: S). (Foldable f, PIsData k, PIsData v) => f (Term s k, Term s v) -> Term s (PMap 'Unsorted k v)

psortedMapFromFoldable :: forall (k :: PType) (v :: PType) (f :: Type -> Type) (s :: S). (Foldable f, POrd k, PIsData k, PIsData v) => f (Term s k, Term s v) -> Term s (PMap 'Sorted k v)

-- | Given a <a>PMap</a> of uncertain order, yield a <a>PMap</a> that is
--   known to be sorted.
passertSorted :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (s :: S). (POrd k, PIsData k, PIsData v) => Term s (PMap any k v :--> PMap 'Sorted k v)

-- | Forget the knowledge that keys were sorted.
pforgetSorted :: forall (g :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S). Term s (PMap 'Sorted k v) -> Term s (PMap g k v)

-- | Applies a function to every value in the map, much like <a>map</a>.
pmap :: forall (g :: KeyGuarantees) (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (s :: S). (PIsData a, PIsData b) => Term s ((a :--> b) :--> (PMap g k a :--> PMap g k b))

-- | As <a>pmap</a>, but over Data representations.
pmapData :: forall (g :: KeyGuarantees) (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (s :: S). Term s ((PAsData a :--> PAsData b) :--> (PMap g k a :--> PMap g k b))

-- | As <a>pmap</a>, but gives key access as well.
pmapWithKey :: forall (k :: PType) (a :: PType) (b :: PType) (keysort :: KeyGuarantees) (s :: S). (PIsData k, PIsData a, PIsData b) => Term s ((k :--> (a :--> b)) :--> (PMap keysort k a :--> PMap 'Unsorted k b))

-- | Maps and filters the map, much like <a>mapMaybe</a>.
pmapMaybe :: forall (g :: KeyGuarantees) (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (s :: S). (PIsData a, PIsData b) => Term s ((a :--> PMaybe b) :--> (PMap g k a :--> PMap g k b))

-- | As <a>pmapMaybe</a>, but over Data representation.
pmapMaybeData :: forall (g :: KeyGuarantees) (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (s :: S). Term s ((PAsData a :--> PMaybe (PAsData b)) :--> (PMap g k a :--> PMap g k b))

-- | Given a comparison function and a "zero" value, check whether a binary
--   relation holds over 2 sorted <a>PMap</a>s.
--   
--   <h1>Important note</h1>
--   
--   This is primarily intended to be used with <tt>PValue</tt>. We assume
--   that the comparison behaves like a comparison would (thus, being at
--   least a partial order, or possibly a total order or equivalence), and
--   that the starting value does not break it. Use with extreme care.
pcheckBinRel :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k, PIsData v) => Term s ((v :--> (v :--> PBool)) :--> (v :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PBool))))

-- | Gives <a>PTrue</a> if both argument <a>PMap</a>s contain mappings for
--   exactly the same set of keys. Requires a number of equality
--   comparisons between keys proportional to the length of the shorter
--   argument.
pkeysEqual :: forall (k :: PType) (a :: PType) (b :: PType) (s :: S). (PIsData k, PEq k) => Term s (PMap 'Sorted k a :--> (PMap 'Sorted k b :--> PBool))

-- | As <a>pkeysEqual</a>, but requires only <a>PEq</a> constraints for the
--   keys, and works for <a>Unsorted</a> <a>PMap</a>s. This requires a
--   number of equality comparisons between keys proportional to the
--   product of the lengths of both arguments: that is, this function is
--   quadratic.
pkeysEqualUnsorted :: forall (k :: PType) (a :: PType) (b :: PType) (s :: S). (PIsData k, PIsData a, PIsData b) => Term s (PMap 'Unsorted k a :--> (PMap 'Unsorted k b :--> PBool))

-- | Verifies all values in the map satisfy the given predicate.
pall :: forall (any :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S). PIsData v => Term s ((v :--> PBool) :--> (PMap any k v :--> PBool))

-- | Tests if anu value in the map satisfies the given predicate.
pany :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (s :: S). PIsData v => Term s ((v :--> PBool) :--> (PMap any k v :--> PBool))

-- | Project all key-value pairs into a <a>Monoid</a>, then combine. Keys
--   and values will be presented in key order.
pfoldMapWithKey :: forall (m :: PType) (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v, forall (s' :: S). Monoid (Term s' m)) => Term s ((k :--> (v :--> m)) :--> (PMap 'Sorted k v :--> m))

-- | Left-associative fold of a <a>PMap</a> with keys. Keys and values will
--   be presented in key order.
pfoldlWithKey :: forall (a :: PType) (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v) => Term s ((a :--> (k :--> (v :--> a))) :--> (a :--> (PMap 'Sorted k v :--> a)))

-- | Build the union of two <a>PMap</a>s, merging values that share the
--   same key using the given function.
punionResolvingCollisionsWith :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k, PIsData v) => Commutativity -> Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the union of two <a>PMap</a>s, merging values that share the
--   same key using the given function.
punionResolvingCollisionsWithData :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k) => Commutativity -> Term s ((PAsData v :--> (PAsData v :--> PAsData v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the union of two <a>PMap</a>s. Take the value from the left
--   argument for colliding keys.
--   
--   Prefer this over 'punionResolvingCollisionsWith NonCommutative # plam
--   const'. It performs better.
pleftBiasedUnion :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k, PIsData v) => Term s (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Difference of two maps. Return elements of the first map not existing
--   in the second map.
pdifference :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (PIsData k, POrd k, PIsData v) => Term s (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Zip two <a>PMap</a>s, using the given potentially non-commutative
--   value merge function for key collisions, and different values for the
--   sides.
pzipWithDefaults :: forall (s :: S) (k :: PType) (v :: PType). (POrd k, PIsData k, PIsData v) => (forall (s' :: S). Term s' v) -> (forall (s' :: S). Term s' v) -> Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the intersection of two <a>PMap</a>s, merging values that share
--   the same key using the given function.
pintersectionWith :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k, PIsData v) => Commutativity -> Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the intersection of two <a>PMap</a>s, merging data-encoded
--   values that share the same key using the given function.
pintersectionWithData :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k) => Commutativity -> Term s ((PAsData v :--> (PAsData v :--> PAsData v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Tests whether the map is empty.
pnull :: forall (any :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S). Term s (PMap any k v :--> PBool)

-- | Look up the given key in a <a>PMap</a>.
plookup :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (s :: S). (PIsData k, PIsData v) => Term s (k :--> (PMap any k v :--> PMaybe v))

-- | as <a>plookup</a>, except over Data representation.
plookupData :: Term s (PAsData k :--> (PMap any k v :--> PMaybe (PAsData v)))

-- | Look up the given key data in a <a>PMap</a>, applying the given
--   function to the found key-value pair.
plookupDataWith :: Term s ((PBuiltinPair (PAsData k) (PAsData v) :--> PMaybe x) :--> (PAsData k :--> (PMap any k v :--> PMaybe x)))

-- | Look up the given key in a <a>PMap</a>, returning the default value if
--   the key is absent.
pfindWithDefault :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (s :: S). (PIsData k, PIsData v) => Term s (v :--> (k :--> (PMap any k v :--> v)))

-- | Look up the given key in a <a>PMap</a>; return the default if the key
--   is absent or apply the argument function to the value data if present.
pfoldAt :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (r :: S -> Type) (s :: S). PIsData k => Term s (k :--> (r :--> ((PAsData v :--> r) :--> (PMap any k v :--> r))))

-- | Look up the given key data in a <a>PMap</a>; return the default if the
--   key is absent or apply the argument function to the value data if
--   present.
pfoldAtData :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (r :: S -> Type) (s :: S). Term s (PAsData k :--> (r :--> ((PAsData v :--> r) :--> (PMap any k v :--> r))))

-- | As <a>plookup</a>, but errors when the key is missing.
ptryLookup :: forall (k :: PType) (v :: PType) (keys :: KeyGuarantees) (s :: S). (PIsData k, PIsData v) => Term s (k :--> (PMap keys k v :--> v))

-- | Insert a new key/value pair into the map, overriding the previous if
--   any.
pinsert :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k, PIsData v) => Term s (k :--> (v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Delete a key from the map.
pdelete :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k) => Term s (k :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Given an 'updater' and a key, if the key exists in the <a>PMap</a>,
--   apply the 'updater' to it, otherwise do nothing. If the 'updater'
--   produces <a>PNothing</a>, the value is deleted; otherwise, it is
--   modified to the result.
--   
--   Performance will be equivalent to a lookup followed by an insert (or
--   delete), as well as the cost of calling the 'updater'.
pupdate :: forall (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v, POrd k) => Term s ((v :--> PMaybe v) :--> (k :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | If a value exists at the specified key, apply the function argument to
--   it; otherwise, do nothing.
padjust :: forall (k :: PType) (v :: PType) (s :: S). (PIsData k, PEq k, PIsData v) => Term s ((v :--> v) :--> (k :--> (PMap 'Unsorted k v :--> PMap 'Unsorted k v)))

-- | Get the key of a key-value pair.
pkvPairKey :: forall (k :: PType) (v :: PType) (s :: S). PIsData k => Term s (PBuiltinPair (PAsData k) (PAsData v) :--> k)

-- | Get the value of a key-value pair.
pkvPairValue :: forall (k :: PType) (v :: PType) (s :: S). PIsData v => Term s (PBuiltinPair (PAsData k) (PAsData v) :--> v)

-- | Compare two key-value pairs by their keys. Gives <a>PTrue</a> if the
--   key of the first argument pair is less than the key of the second
--   argument pair.
pkvPairLt :: forall (k :: PType) (v :: PType) (s :: S). (PIsData k, PPartialOrd k) => Term s (PBuiltinPair (PAsData k) (PAsData v) :--> (PBuiltinPair (PAsData k) (PAsData v) :--> PBool))

-- | Get a list-like structure full of the keys of the argument
--   <a>PMap</a>. If the <a>PMap</a> is <a>Sorted</a>, the keys will
--   maintain that order, and will be unique; otherwise, the order is
--   unspecified, and duplicates may exist.
--   
--   <h1>Note</h1>
--   
--   You will need to specify what manner of list-like structure you want;
--   we have arranged the type signature to make specifying this easy with
--   <tt>TypeApplications</tt>.
pkeys :: forall (ell :: PType -> PType) (k :: PType) (v :: PType) (keys :: KeyGuarantees) (s :: S). (PListLike ell, PElemConstraint ell (PAsData k)) => Term s (PMap keys k v :--> ell (PAsData k))
instance (Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, Plutarch.Show.PShow k, Plutarch.Show.PShow v) => Plutarch.Show.PShow (Plutarch.LedgerApi.AssocMap.PMap keysort k v)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.AssocMap.PMap keysort k v)
instance GHC.Generics.Generic (Plutarch.LedgerApi.AssocMap.PMap keysort k v s)
instance GHC.Show.Show Plutarch.LedgerApi.AssocMap.Commutativity
instance GHC.Classes.Ord Plutarch.LedgerApi.AssocMap.Commutativity
instance GHC.Classes.Eq Plutarch.LedgerApi.AssocMap.Commutativity
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.SomeMergeHandler_ f k v)
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.MergeHandler_ f k v)
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.MergeHandlerCommutative_ f k v)
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.BothPresentHandler_ f k v)
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.BothPresentHandlerCommutative_ f k v)
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.OnePresentHandler_ f k v)
instance Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.LedgerApi.AssocMap.PMap keysort k v)
instance Plutarch.Builtin.PIsData (Plutarch.LedgerApi.AssocMap.PMap keysort k v)
instance Plutarch.Bool.PEq (Plutarch.LedgerApi.AssocMap.PMap 'Plutarch.LedgerApi.AssocMap.Sorted k v)
instance (PlutusTx.Eq.Eq (Plutarch.Lift.PLifted k), Plutarch.DataRepr.Internal.PLiftData k, Plutarch.DataRepr.Internal.PLiftData v, GHC.Classes.Ord (Plutarch.Lift.PLifted k)) => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.LedgerApi.AssocMap.PMap 'Plutarch.LedgerApi.AssocMap.Unsorted k v)
instance (PlutusTx.Eq.Eq k, Plutarch.DataRepr.Internal.PConstantData k, Plutarch.DataRepr.Internal.PConstantData v, GHC.Classes.Ord k) => Plutarch.Lift.PConstantDecl (PlutusTx.AssocMap.Map k v)
instance (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData k), Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData v)) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.AssocMap.PMap 'Plutarch.LedgerApi.AssocMap.Unsorted k v))
instance (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData k), Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData v)) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.AssocMap.PMap 'Plutarch.LedgerApi.AssocMap.Sorted k v))


-- | Value-related functionality. In order to keep the interface efficient
--   and safe at the same time, there is a type-level distinction between
--   <a>PValue</a>s that are guaranteed to be properly normalized and those
--   that provide no such guarantee.
--   
--   Also for efficiency reasons, the Ada-specific functions assume that
--   there can be only one token name for the Ada currency symbol, and they
--   don't check whether it matches <a>adaToken</a>.
module Plutarch.LedgerApi.Value

newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)

newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s (PDataNewtype PByteString) -> PCurrencySymbol (s :: S)

newtype PTokenName (s :: S)
PTokenName :: Term s (PDataNewtype PByteString) -> PTokenName (s :: S)

data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees

newtype PLovelace (s :: S)
PLovelace :: Term s (PDataNewtype PInteger) -> PLovelace (s :: S)

-- | @since WIP
newtype PAssetClass (s :: S)
PAssetClass :: Term s (PDataNewtype (PBuiltinPair (PAsData PCurrencySymbol) (PAsData PTokenName))) -> PAssetClass (s :: S)

-- | The <a>PCurrencySymbol</a> of the Ada currency.
padaSymbol :: forall (s :: S). Term s PCurrencySymbol

-- | Data-encoded <a>PCurrencySymbol</a> of the Ada currency.
padaSymbolData :: forall (s :: S). Term s (PAsData PCurrencySymbol)

-- | The <a>PTokenName</a> of the Ada currency.
padaToken :: Term s PTokenName

-- | Construct a singleton <a>PValue</a> containing only the given quantity
--   of the given currency.
psingleton :: forall (s :: S). Term s (PCurrencySymbol :--> (PTokenName :--> (PInteger :--> PValue 'Sorted 'NonZero)))

-- | Construct a singleton <a>PValue</a> containing only the given quantity
--   of the given currency, taking data-encoded parameters.
psingletonData :: forall (s :: S). Term s (PAsData PCurrencySymbol :--> (PAsData PTokenName :--> (PAsData PInteger :--> PValue 'Sorted 'NonZero)))

-- | Construct a constant singleton <a>PValue</a> containing only the given
--   positive quantity of the given currency.
pconstantPositiveSingleton :: forall (s :: S). (forall (s' :: S). Term s' PCurrencySymbol) -> (forall (s' :: S). Term s' PTokenName) -> (forall (s' :: S). Term s' PInteger) -> Term s (PValue 'Sorted 'Positive)

-- | Given a <a>PValue</a>, either construct another <a>PValue</a> with the
--   same contents and a proof that all amounts in it are positive, or
--   error.
passertPositive :: forall (kg :: KeyGuarantees) (ag :: AmountGuarantees) (s :: S). Term s (PValue kg ag :--> PValue kg 'Positive)

-- | Assert the value is properly sorted and normalized.
passertSorted :: forall (anyKey :: KeyGuarantees) (anyAmount :: AmountGuarantees) (s :: S). Term s (PValue anyKey anyAmount :--> PValue 'Sorted 'NonZero)

-- | 'Forget' that a <tt>Value</tt> has an only-positive guarantee.
pforgetPositive :: forall (a :: AmountGuarantees) (k :: KeyGuarantees) (s :: S). Term s (PValue k 'Positive) -> Term s (PValue k a)

-- | Forget the knowledge of all value's guarantees.
pforgetSorted :: forall (a :: AmountGuarantees) (k :: KeyGuarantees) (s :: S). Term s (PValue 'Sorted a) -> Term s (PValue k a)

-- | Normalize the argument to contain no zero quantity nor empty token
--   map.
pnormalize :: forall (any :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted any :--> PValue 'Sorted 'NonZero)

-- | Strip all non-Ada from a <a>PValue</a>.
padaOnlyValue :: forall (v :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted v :--> PValue 'Sorted v)

-- | Strip all Ada from a <a>PValue</a>.
pnoAdaValue :: forall (v :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted v :--> PValue 'Sorted v)

-- | Given a description of a relation on amounts, check whether that
--   relation holds over sorted <a>PValue</a>s.
--   
--   <h1>Important note</h1>
--   
--   This is intended for use with boolean comparison functions, which must
--   define at least a partial order (total orders and equivalences are
--   acceptable as well). Use of this with anything else is not guaranteed
--   to give anything resembling a sensible answer. Use with extreme care.
pcheckBinRel :: forall (any0 :: AmountGuarantees) (any1 :: AmountGuarantees) (s :: S). Term s ((PInteger :--> (PInteger :--> PBool)) :--> (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PBool)))

-- | Combine two <a>PValue</a>s, taking the tokens from the left only, if a
--   currency occurs on both sides.
pleftBiasedCurrencyUnion :: forall (any0 :: AmountGuarantees) (any1 :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees))

-- | Combine two <a>PValue</a>s, taking the tokens from the left only, if a
--   token name of the same currency occurs on both sides.
--   
--   Prefer this over 'punionResolvingCollisionsWith NonCommutative # plam
--   const'. It is equivalent, but performs better.
pleftBiasedTokenUnion :: forall (any0 :: AmountGuarantees) (any1 :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees))

-- | Combine two <a>PValue</a>s applying the given function to any pair of
--   quantities with the same asset class. Note that the result is _not_
--   <tt>normalize</tt>d and may contain zero quantities.
punionResolvingCollisionsWith :: forall (any0 :: AmountGuarantees) (any1 :: AmountGuarantees) (s :: S). Commutativity -> Term s ((PInteger :--> (PInteger :--> PInteger)) :--> (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees)))

-- | Combine two <a>PValue</a>s applying the given function to any pair of
--   data-encoded quantities with the same asset class. Note that the
--   result is _not_ <tt>normalize</tt>d and may contain zero quantities.
punionResolvingCollisionsWithData :: forall (any0 :: AmountGuarantees) (any1 :: AmountGuarantees) (s :: S). Commutativity -> Term s ((PAsData PInteger :--> (PAsData PInteger :--> PAsData PInteger)) :--> (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees)))

-- | Get the quantity of the given currency in the <a>PValue</a>.
pvalueOf :: forall (anyKey :: KeyGuarantees) (anyAmount :: AmountGuarantees) (s :: S). Term s (PValue anyKey anyAmount :--> (PCurrencySymbol :--> (PTokenName :--> PInteger)))

-- | Get the amount of Lovelace in the <a>PValue</a>.
plovelaceValueOf :: forall (v :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted v :--> PInteger)

-- | Test if the value contains nothing but Ada
pisAdaOnlyValue :: forall (s :: S). Term s (PValue 'Sorted 'Positive :--> PBool)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Show.PShow Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Bool.PPartialOrd Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Bool.PEq Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Value.PLovelace
instance GHC.Generics.Generic (Plutarch.LedgerApi.Value.PLovelace s)
instance Plutarch.Show.PShow Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.Bool.POrd Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.Bool.PPartialOrd Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.Bool.PEq Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Value.PTokenName
instance GHC.Generics.Generic (Plutarch.LedgerApi.Value.PTokenName s)
instance Plutarch.Show.PShow Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Bool.POrd Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Bool.PPartialOrd Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Bool.PEq Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Value.PCurrencySymbol
instance GHC.Generics.Generic (Plutarch.LedgerApi.Value.PCurrencySymbol s)
instance Plutarch.Show.PShow (Plutarch.LedgerApi.Value.PValue keys amounts)
instance Plutarch.Builtin.PIsData (Plutarch.LedgerApi.Value.PValue keys amounts)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Value.PValue keys amounts)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Value.PValue keys amounts s)
instance Plutarch.Bool.POrd Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Show.PShow Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Bool.PEq Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Value.PAssetClass
instance GHC.Generics.Generic (Plutarch.LedgerApi.Value.PAssetClass s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.Lovelace
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.TokenName
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.CurrencySymbol
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.Value
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.AssetClass
instance Plutarch.Bool.PPartialOrd Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.Value.PAssetClass)
instance Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.LedgerApi.Value.PValue keys amounts)
instance Plutarch.Lift.PUnsafeLiftDecl (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Unsorted 'Plutarch.LedgerApi.Value.NoGuarantees)
instance Plutarch.Bool.PEq (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.Positive)
instance Plutarch.Bool.PEq (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero)
instance Plutarch.Bool.PPartialOrd (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.Positive)
instance Plutarch.Bool.PPartialOrd (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero)
instance Plutarch.Bool.PEq (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees)
instance GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.Positive))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.Positive))
instance GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero))
instance GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees))
instance GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted normalization)) => GHC.Base.Monoid (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted normalization))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted normalization)) => PlutusTx.Monoid.Monoid (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted normalization))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees)) => PlutusTx.Monoid.Group (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero)) => PlutusTx.Monoid.Group (Plutarch.Internal.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Unsorted 'Plutarch.LedgerApi.Value.NoGuarantees))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.Positive))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Unsorted 'Plutarch.LedgerApi.Value.Positive))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Unsorted 'Plutarch.LedgerApi.Value.NonZero))
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.Value.PCurrencySymbol)
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.Value.PTokenName)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.Value.PLovelace)


-- | <h1>Note</h1>
--   
--   The <a>PValue</a>, <a>PMap</a> and <a>PInterval</a>-related
--   functionality can be found in other modules, as these clash with the
--   Plutarch prelude. These should be imported qualified.
module Plutarch.LedgerApi.V3

newtype PScriptContext (s :: S)
PScriptContext :: Term s (PDataRecord '["txInfo" ':= PTxInfo, "redeemer" ':= PRedeemer, "scriptInfo" ':= PScriptInfo]) -> PScriptContext (s :: S)
newtype PTxInfo (s :: S)
PTxInfo :: Term s (PDataRecord '["inputs" ':= PBuiltinList (PAsData PTxInInfo), "referenceInputs" ':= PBuiltinList (PAsData PTxInInfo), "outputs" ':= PBuiltinList (PAsData PTxOut), "fee" ':= PLovelace, "mint" ':= PValue 'Sorted 'NonZero, "txCerts" ':= PBuiltinList (PAsData PTxCert), "wdrl" ':= PMap 'Unsorted PCredential PLovelace, "validRange" ':= PInterval PPosixTime, "signatories" ':= PBuiltinList (PAsData PPubKeyHash), "redeemers" ':= PMap 'Unsorted PScriptPurpose PRedeemer, "data" ':= PMap 'Unsorted PDatumHash PDatum, "id" ':= PTxId, "votes" ':= PMap 'Unsorted PVoter (PMap 'Unsorted PGovernanceActionId PVote), "proposalProcedures" ':= PBuiltinList (PAsData PProposalProcedure), "currentTreasuryAmount" ':= PMaybeData PLovelace, "treasuryDonation" ':= PMaybeData PLovelace]) -> PTxInfo (s :: S)

data PScriptInfo (s :: S)
PMintingScript :: Term s (PDataRecord '["_0" ':= PCurrencySymbol]) -> PScriptInfo (s :: S)
PSpendingScript :: Term s (PDataRecord '["_0" ':= PTxOutRef, "_1" ':= PMaybeData PDatum]) -> PScriptInfo (s :: S)
PRewardingScript :: Term s (PDataRecord '["_0" ':= PCredential]) -> PScriptInfo (s :: S)
PCertifyingScript :: Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PTxCert]) -> PScriptInfo (s :: S)
PVotingScript :: Term s (PDataRecord '["_0" ':= PVoter]) -> PScriptInfo (s :: S)
PProposingScript :: Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PProposalProcedure]) -> PScriptInfo (s :: S)

data PScriptPurpose (s :: S)
PMinting :: Term s (PDataRecord '["_0" ':= PCurrencySymbol]) -> PScriptPurpose (s :: S)
PSpending :: Term s (PDataRecord '["_0" ':= PTxOutRef]) -> PScriptPurpose (s :: S)

PRewarding :: Term s (PDataRecord '["_0" ':= PCredential]) -> PScriptPurpose (s :: S)
PCertifying :: Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PTxCert]) -> PScriptPurpose (s :: S)

PVoting :: Term s (PDataRecord '["_0" ':= PVoter]) -> PScriptPurpose (s :: S)

PProposing :: Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PProposalProcedure]) -> PScriptPurpose (s :: S)

newtype PTxOutRef (s :: S)
PTxOutRef :: Term s (PDataRecord '["id" ':= PTxId, "idx" ':= PInteger]) -> PTxOutRef (s :: S)

newtype PTxOut (s :: S)
PTxOut :: Term s (PDataRecord '["address" ':= PAddress, "value" ':= PValue 'Sorted 'Positive, "datum" ':= POutputDatum, "referenceScript" ':= PMaybeData PScriptHash]) -> PTxOut (s :: S)

-- | Hashed with <tt>BLAKE2b-256</tt>.
newtype PTxId (s :: S)
PTxId :: Term s (PDataNewtype PByteString) -> PTxId (s :: S)

-- | An input of the pending transaction.
newtype PTxInInfo (s :: S)
PTxInInfo :: Term s (PDataRecord '["outRef" ':= PTxOutRef, "resolved" ':= PTxOut]) -> PTxInInfo (s :: S)

data POutputDatum (s :: S)
PNoOutputDatum :: Term s (PDataRecord '[]) -> POutputDatum (s :: S)
POutputDatumHash :: Term s (PDataRecord '["datumHash" ':= PDatumHash]) -> POutputDatum (s :: S)

-- | Inline datum as per <a>CIP-0032</a>
POutputDatum :: Term s (PDataRecord '["outputDatum" ':= PDatum]) -> POutputDatum (s :: S)

-- | Find the output txns corresponding to the input being validated.
--   
--   Takes as arguments the inputs, outputs and the spending transaction
--   referenced from <tt>PScriptPurpose</tt>.
--   
--   <b>Example:</b>
--   
--   <pre>
--   ctx &lt;- tcont $ pletFields <tt>["txInfo", "purpose"] sc
--   pmatchC (getField </tt>"purpose" ctx) &gt;&gt;= case
--     PSpending outRef' -&gt; do
--       let outRef = pfield <tt>"_0" # outRef'
--           inputs = pfield </tt>"inputs" # (getField <tt>"txInfo" ctx)
--           outputs = pfield </tt>"outputs" # (getField @"txInfo" ctx)
--       pure $ pgetContinuingOutputs # inputs # outputs # outRef
--     _ -&gt;
--       pure $ ptraceInfoError "not a spending tx"
--   
--   </pre>
pgetContinuingOutputs :: forall (s :: S). Term s (PBuiltinList PTxInInfo :--> (PBuiltinList PTxOut :--> (PTxOutRef :--> PBuiltinList PTxOut)))

-- | Find the input being spent in the current transaction.
--   
--   Takes as arguments the inputs, as well as the spending transaction
--   referenced from <tt>PScriptPurpose</tt>.
--   
--   <b>Example:</b>
--   
--   <pre>
--   ctx &lt;- tcont $ pletFields <tt>["txInfo", "purpose"] sc
--   pmatchC (getField </tt>"purpose" ctx) &gt;&gt;= case
--     PSpending outRef' -&gt; do
--       let outRef = pfield <tt>"_0" # outRef'
--           inputs = pfield </tt>"inputs" # (getField @"txInfo" ctx)
--       pure $ pfindOwnInput # inputs # outRef
--     _ -&gt;
--       pure $ ptraceInfoError "not a spending tx"
--   
--   </pre>
pfindOwnInput :: forall (s :: S). Term s (PBuiltinList PTxInInfo :--> (PTxOutRef :--> PMaybe PTxInInfo))

newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)

newtype PDatumHash (s :: S)
PDatumHash :: Term s (PDataNewtype PByteString) -> PDatumHash (s :: S)

newtype PRedeemer (s :: S)
PRedeemer :: Term s PData -> PRedeemer (s :: S)

newtype PRedeemerHash (s :: S)
PRedeemerHash :: Term s (PDataNewtype PByteString) -> PRedeemerHash (s :: S)

newtype PScriptHash (s :: S)
PScriptHash :: Term s (PDataNewtype PByteString) -> PScriptHash (s :: S)

-- | Hash a script, appending the Plutus V2 prefix.
scriptHash :: Script -> ScriptHash

datumHash :: Datum -> DatumHash

redeemerHash :: Redeemer -> RedeemerHash

dataHash :: forall (a :: Type). ToData a => a -> BuiltinByteString

-- | Lookup up the datum given the datum hash.
--   
--   Takes as argument the datum assoc list from a <tt>PTxInfo</tt>.
--   Validates the datum using <a>PTryFrom</a>.
--   
--   <b>Example:</b>
--   
--   <pre>
--   pparseDatum <tt>MyType # datumHash #$ pfield </tt>"datums" # txinfo
--   
--   </pre>
pparseDatum :: forall (a :: S -> Type) (s :: S). PTryFrom PData (PAsData a) => Term s (PDatumHash :--> (PMap 'Unsorted PDatumHash PDatum :--> PMaybe (PAsData a)))

newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)

data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees

newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s (PDataNewtype PByteString) -> PCurrencySymbol (s :: S)

newtype PTokenName (s :: S)
PTokenName :: Term s (PDataNewtype PByteString) -> PTokenName (s :: S)

newtype PLovelace (s :: S)
PLovelace :: Term s (PDataNewtype PInteger) -> PLovelace (s :: S)

newtype PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)

data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees

data Commutativity
Commutative :: Commutativity
NonCommutative :: Commutativity

data PCredential (s :: S)
PPubKeyCredential :: Term s (PDataRecord '["_0" ':= PPubKeyHash]) -> PCredential (s :: S)
PScriptCredential :: Term s (PDataRecord '["_0" ':= PScriptHash]) -> PCredential (s :: S)

data PStakingCredential (s :: S)
PStakingHash :: Term s (PDataRecord '["_0" ':= PCredential]) -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PInteger, "_2" ':= PInteger]) -> PStakingCredential (s :: S)

newtype PAddress (s :: S)
PAddress :: Term s (PDataRecord '["credential" ':= PCredential, "stakingCredential" ':= PMaybeData PStakingCredential]) -> PAddress (s :: S)

newtype PPosixTime (s :: S)
PPosixTime :: Term s (PDataNewtype PInteger) -> PPosixTime (s :: S)

-- | Construct a <a>PPosixTime</a> from a <a>PInteger</a>. Same as using
--   the constructor, but a lot shorter.
--   
--   @since WIP
pposixTime :: forall (s :: S). Term s PInteger -> Term s PPosixTime

-- | Unwrap a <a>PPosixTime</a> to get a <a>PInteger</a>. Same as using
--   <a>pmatch</a>, but a lot shorter. Also unwraps the <tt>Data</tt>
--   encoding.
--   
--   @since WIP
unPPosixTime :: forall (s :: S). Term s PPosixTime -> Term s PInteger

newtype PInterval (a :: S -> Type) (s :: S)
PInterval :: Term s (PDataRecord '["from" ':= PLowerBound a, "to" ':= PUpperBound a]) -> PInterval (a :: S -> Type) (s :: S)

newtype PLowerBound (a :: S -> Type) (s :: S)
PLowerBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PBool]) -> PLowerBound (a :: S -> Type) (s :: S)

newtype PUpperBound (a :: S -> Type) (s :: S)
PUpperBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PBool]) -> PUpperBound (a :: S -> Type) (s :: S)

data PExtended (a :: S -> Type) (s :: S)
PNegInf :: Term s (PDataRecord '[]) -> PExtended (a :: S -> Type) (s :: S)
PFinite :: Term s (PDataRecord '["_0" ':= a]) -> PExtended (a :: S -> Type) (s :: S)
PPosInf :: Term s (PDataRecord '[]) -> PExtended (a :: S -> Type) (s :: S)

data PTxCert (s :: S)
PTxCertRegStaking :: Term s (PDataRecord '["_0" ':= PCredential, "_1" ':= PMaybeData PLovelace]) -> PTxCert (s :: S)
PTxCertUnRegStaking :: Term s (PDataRecord '["_0" ':= PCredential, "_1" ':= PMaybeData PLovelace]) -> PTxCert (s :: S)
PTxCertDelegStaking :: Term s (PDataRecord '["_0" ':= PCredential, "_1" ':= PDelegatee]) -> PTxCert (s :: S)
PTxCertRegDeleg :: Term s (PDataRecord '["_0" ':= PCredential, "_1" ':= PDelegatee, "_2" ':= PLovelace]) -> PTxCert (s :: S)
PTxCertRegDRep :: Term s (PDataRecord '["_0" ':= PDRepCredential, "_1" ':= PLovelace]) -> PTxCert (s :: S)
PTxCertUpdateDRep :: Term s (PDataRecord '["_0" ':= PDRepCredential]) -> PTxCert (s :: S)
PTxCertUnRegDRep :: Term s (PDataRecord '["_0" ':= PDRepCredential, "_1" ':= PLovelace]) -> PTxCert (s :: S)
PTxCertPoolRegister :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PPubKeyHash]) -> PTxCert (s :: S)
PTxCertPoolRetire :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PInteger]) -> PTxCert (s :: S)
PTxCertAuthHotCommittee :: Term s (PDataRecord '["_0" ':= PColdCommitteeCredential, "_1" ':= PHotCommitteeCredential]) -> PTxCert (s :: S)
PTxCertResignColdCommittee :: Term s (PDataRecord '["_0" ':= PColdCommitteeCredential]) -> PTxCert (s :: S)

data PDelegatee (s :: S)
PDelegStake :: Term s (PDataRecord '["_0" ':= PPubKeyHash]) -> PDelegatee (s :: S)
PDelegVote :: Term s (PDataRecord '["_0" ':= PDRep]) -> PDelegatee (s :: S)
PDelegStakeVote :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PDRep]) -> PDelegatee (s :: S)

newtype PDRepCredential (s :: S)
PDRepCredential :: Term s PCredential -> PDRepCredential (s :: S)

newtype PColdCommitteeCredential (s :: S)
PColdCommitteeCredential :: Term s PCredential -> PColdCommitteeCredential (s :: S)

newtype PHotCommitteeCredential (s :: S)
PHotCommitteeCredential :: Term s PCredential -> PHotCommitteeCredential (s :: S)

data PDRep (s :: S)
PDRep :: Term s (PDataRecord '["_0" ':= PDRepCredential]) -> PDRep (s :: S)
PDRepAlwaysAbstain :: Term s (PDataRecord '[]) -> PDRep (s :: S)
PDRepAlwaysNoConfidence :: Term s (PDataRecord '[]) -> PDRep (s :: S)

data PVoter (s :: S)
PCommitteeVoter :: Term s (PDataRecord '["_0" ':= PHotCommitteeCredential]) -> PVoter (s :: S)
PDRepVoter :: Term s (PDataRecord '["_0" ':= PDRepCredential]) -> PVoter (s :: S)
PStakePoolVoter :: Term s (PDataRecord '["_0" ':= PPubKeyHash]) -> PVoter (s :: S)

newtype PGovernanceActionId (s :: S)
PGovernanceActionId :: Term s (PDataRecord '["txId" ':= PTxId, "govActionIx" ':= PInteger]) -> PGovernanceActionId (s :: S)

data PVote (s :: S)
PVoteYes :: Term s (PDataRecord '[]) -> PVote (s :: S)
PVoteNo :: Term s (PDataRecord '[]) -> PVote (s :: S)
PAbstain :: Term s (PDataRecord '[]) -> PVote (s :: S)

newtype PProtocolVersion (s :: S)
PProtocolVersion :: Term s (PDataRecord '["major" ':= PInteger, "minor" ':= PInteger]) -> PProtocolVersion (s :: S)

newtype PProposalProcedure (s :: S)
PProposalProcedure :: Term s (PDataRecord '["deposit" ':= PLovelace, "returnAddr" ':= PCredential, "governanceAction" ':= PGovernanceAction]) -> PProposalProcedure (s :: S)

data PGovernanceAction (s :: S)
PParameterChange :: Term s (PDataRecord '["_0" ':= PMaybeData PGovernanceActionId, "_1" ':= PChangedParameters, "_2" ':= PMaybeData PScriptHash]) -> PGovernanceAction (s :: S)
PHardForkInitiation :: Term s (PDataRecord '["_0" ':= PMaybeData PGovernanceActionId, "_1" ':= PProtocolVersion]) -> PGovernanceAction (s :: S)
PTreasuryWithdrawals :: Term s (PDataRecord '["_0" ':= PMap 'Unsorted PCredential PLovelace, "_1" ':= PMaybeData PScriptHash]) -> PGovernanceAction (s :: S)
PNoConfidence :: Term s (PDataRecord '["_0" ':= PMaybeData PGovernanceActionId]) -> PGovernanceAction (s :: S)
PUpdateCommittee :: Term s (PDataRecord '["_0" ':= PMaybeData PGovernanceActionId, "_1" ':= PBuiltinList (PAsData PColdCommitteeCredential), "_2" ':= PMap 'Unsorted PColdCommitteeCredential PInteger, "_3" ':= PRationalData]) -> PGovernanceAction (s :: S)
PNewConstitution :: Term s (PDataRecord '["_0" ':= PMaybeData PGovernanceActionId, "_1" ':= PConstitution]) -> PGovernanceAction (s :: S)
PInfoAction :: Term s (PDataRecord '[]) -> PGovernanceAction (s :: S)

newtype PChangedParameters (s :: S)
PChangedParameters :: Term s PData -> PChangedParameters (s :: S)

-- | A constitution, omitting the optional anchor.
newtype PConstitution (s :: S)
PConstitution :: Term s (PDataRecord '["_0" := PMaybeData PScriptHash]) -> PConstitution (s :: S)

newtype PCommittee (s :: S)
PCommittee :: Term s (PDataRecord '["members" ':= PMap 'Unsorted PColdCommitteeCredential PInteger, "quorum" ':= PRationalData]) -> PCommittee (s :: S)

newtype PubKey
PubKey :: LedgerBytes -> PubKey

[$sel:getPubKey:PubKey] :: PubKey -> LedgerBytes

newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s (PDataNewtype PByteString) -> PPubKeyHash (s :: S)

pubKeyHash :: PubKey -> PubKeyHash

-- | @since WIP
data PMaybeData (a :: S -> Type) (s :: S)
PDJust :: Term s (PAsData a) -> PMaybeData (a :: S -> Type) (s :: S)
PDNothing :: PMaybeData (a :: S -> Type) (s :: S)

-- | A Rational type that corresponds to the data encoding used by
--   <a>Rational</a>.
newtype PRationalData s
PRationalData :: Term s (PDataRecord '["numerator" ':= PInteger, "denominator" ':= PPositive]) -> PRationalData s

-- | Extracts the element out of a <a>PDJust</a> and throws an error if its
--   argument is <a>PDNothing</a>.
pfromDJust :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybeData a :--> a)

-- | Yield <a>PTrue</a> if a given <a>PMaybeData</a> is of the form
--   <tt><a>PDJust</a> _</tt>.
pisDJust :: forall (a :: PType) (s :: S). Term s (PMaybeData a :--> PBool)

-- | Special version of <tt>pmaybe</tt> that works with <a>PMaybeData</a>.
pmaybeData :: forall (a :: PType) (b :: PType) (s :: S). PIsData a => Term s (b :--> ((a :--> b) :--> (PMaybeData a :--> b)))

-- | Construct a <a>PDJust</a> value.
pdjust :: forall (a :: PType) (s :: S). PIsData a => Term s (a :--> PMaybeData a)

-- | Construct a <a>PDNothing</a> value.
pdnothing :: forall (a :: PType) (s :: S). Term s (PMaybeData a)

-- | Construct a <a>PMaybeData</a> given a <a>PMaybe</a>. Could be useful
--   if you want to "lift" from <a>PMaybe</a> to <a>Maybe</a>.
pmaybeToMaybeData :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybe a :--> PMaybeData a)

-- | Extract the value stored in a <a>PMaybeData</a> container. If there's
--   no value, throw an error with the given message.
passertPDJust :: forall (a :: PType) (s :: S). PIsData a => Term s (PString :--> (PMaybeData a :--> a))

prationalFromData :: ClosedTerm (PRationalData :--> PRational)
instance GHC.Show.Show Plutarch.LedgerApi.V3.PubKey
instance GHC.Classes.Ord Plutarch.LedgerApi.V3.PubKey
instance GHC.Classes.Eq Plutarch.LedgerApi.V3.PubKey

module Plutarch.LedgerApi.V2

data PScriptPurpose (s :: S)
PMinting :: Term s (PDataRecord '["_0" ':= PCurrencySymbol]) -> PScriptPurpose (s :: S)
PSpending :: Term s (PDataRecord '["_0" ':= PTxOutRef]) -> PScriptPurpose (s :: S)
PRewarding :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PScriptPurpose (s :: S)
PCertifying :: Term s (PDataRecord '["_0" ':= PDCert]) -> PScriptPurpose (s :: S)

newtype PScriptContext (s :: S)
PScriptContext :: Term s (PDataRecord '["txInfo" ':= PTxInfo, "purpose" ':= PScriptPurpose]) -> PScriptContext (s :: S)

data PDCert (s :: S)
PDCertDelegRegKey :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDeRegKey :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDelegate :: Term s (PDataRecord '["_0" ':= PStakingCredential, "_1" ':= PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRegister :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRetire :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PInteger]) -> PDCert (s :: S)
PDCertGenesis :: Term s (PDataRecord '[]) -> PDCert (s :: S)
PDCertMir :: Term s (PDataRecord '[]) -> PDCert (s :: S)

data PCredential (s :: S)
PPubKeyCredential :: Term s (PDataRecord '["_0" ':= PPubKeyHash]) -> PCredential (s :: S)
PScriptCredential :: Term s (PDataRecord '["_0" ':= PScriptHash]) -> PCredential (s :: S)

data PStakingCredential (s :: S)
PStakingHash :: Term s (PDataRecord '["_0" ':= PCredential]) -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PInteger, "_2" ':= PInteger]) -> PStakingCredential (s :: S)

newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)

data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees

newtype PLovelace (s :: S)
PLovelace :: Term s (PDataNewtype PInteger) -> PLovelace (s :: S)

newtype PTokenName (s :: S)
PTokenName :: Term s (PDataNewtype PByteString) -> PTokenName (s :: S)

newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s (PDataNewtype PByteString) -> PCurrencySymbol (s :: S)

newtype PPosixTime (s :: S)
PPosixTime :: Term s (PDataNewtype PInteger) -> PPosixTime (s :: S)

-- | Construct a <a>PPosixTime</a> from a <a>PInteger</a>. Same as using
--   the constructor, but a lot shorter.
--   
--   @since WIP
pposixTime :: forall (s :: S). Term s PInteger -> Term s PPosixTime

-- | Unwrap a <a>PPosixTime</a> to get a <a>PInteger</a>. Same as using
--   <a>pmatch</a>, but a lot shorter. Also unwraps the <tt>Data</tt>
--   encoding.
--   
--   @since WIP
unPPosixTime :: forall (s :: S). Term s PPosixTime -> Term s PInteger

data PExtended (a :: S -> Type) (s :: S)
PNegInf :: Term s (PDataRecord '[]) -> PExtended (a :: S -> Type) (s :: S)
PFinite :: Term s (PDataRecord '["_0" ':= a]) -> PExtended (a :: S -> Type) (s :: S)
PPosInf :: Term s (PDataRecord '[]) -> PExtended (a :: S -> Type) (s :: S)

newtype PLowerBound (a :: S -> Type) (s :: S)
PLowerBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PBool]) -> PLowerBound (a :: S -> Type) (s :: S)

newtype PUpperBound (a :: S -> Type) (s :: S)
PUpperBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PBool]) -> PUpperBound (a :: S -> Type) (s :: S)

newtype PInterval (a :: S -> Type) (s :: S)
PInterval :: Term s (PDataRecord '["from" ':= PLowerBound a, "to" ':= PUpperBound a]) -> PInterval (a :: S -> Type) (s :: S)

newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)

newtype PRedeemer (s :: S)
PRedeemer :: Term s PData -> PRedeemer (s :: S)

newtype PDatumHash (s :: S)
PDatumHash :: Term s (PDataNewtype PByteString) -> PDatumHash (s :: S)

newtype PRedeemerHash (s :: S)
PRedeemerHash :: Term s (PDataNewtype PByteString) -> PRedeemerHash (s :: S)

newtype PScriptHash (s :: S)
PScriptHash :: Term s (PDataNewtype PByteString) -> PScriptHash (s :: S)

newtype PAddress (s :: S)
PAddress :: Term s (PDataRecord '["credential" ':= PCredential, "stakingCredential" ':= PMaybeData PStakingCredential]) -> PAddress (s :: S)

newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s (PDataNewtype PByteString) -> PPubKeyHash (s :: S)

-- | Hashed with <tt>BLAKE2b-256</tt>.
newtype PTxId (s :: S)
PTxId :: Term s (PDataRecord '["_0" ':= PByteString]) -> PTxId (s :: S)

newtype PTxInfo (s :: S)
PTxInfo :: Term s (PDataRecord '["inputs" ':= PBuiltinList (PAsData PTxInInfo), "referenceInputs" ':= PBuiltinList (PAsData PTxInInfo), "outputs" ':= PBuiltinList (PAsData PTxOut), "fee" ':= PValue 'Sorted 'Positive, "mint" ':= PValue 'Sorted 'NoGuarantees, "dcert" ':= PBuiltinList (PAsData PDCert), "wdrl" ':= PMap 'Unsorted PStakingCredential PInteger, "validRange" ':= PInterval PPosixTime, "signatories" ':= PBuiltinList (PAsData PPubKeyHash), "redeemers" ':= PMap 'Unsorted PScriptPurpose PRedeemer, "data" ':= PMap 'Unsorted PDatumHash PDatum, "id" ':= PTxId]) -> PTxInfo (s :: S)

newtype PTxOut (s :: S)
PTxOut :: Term s (PDataRecord '["address" ':= PAddress, "value" ':= PValue 'Sorted 'Positive, "datum" ':= POutputDatum, "referenceScript" ':= PMaybeData PScriptHash]) -> PTxOut (s :: S)

-- | Reference to a transaction output, with an index referencing which
--   exact output we mean.
newtype PTxOutRef (s :: S)
PTxOutRef :: Term s (PDataRecord '["id" ':= PTxId, "idx" ':= PInteger]) -> PTxOutRef (s :: S)

newtype PTxInInfo (s :: S)
PTxInInfo :: Term s (PDataRecord '["outRef" ':= PTxOutRef, "resolved" ':= PTxOut]) -> PTxInInfo (s :: S)

data POutputDatum (s :: S)
PNoOutputDatum :: Term s (PDataRecord '[]) -> POutputDatum (s :: S)
POutputDatumHash :: Term s (PDataRecord '["datumHash" ':= PDatumHash]) -> POutputDatum (s :: S)

-- | Inline datum as per <a>CIP-0032</a>
POutputDatum :: Term s (PDataRecord '["outputDatum" ':= PDatum]) -> POutputDatum (s :: S)

newtype PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)

data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees

data Commutativity
Commutative :: Commutativity
NonCommutative :: Commutativity

-- | @since WIP
data PMaybeData (a :: S -> Type) (s :: S)
PDJust :: Term s (PAsData a) -> PMaybeData (a :: S -> Type) (s :: S)
PDNothing :: PMaybeData (a :: S -> Type) (s :: S)

-- | A Rational type that corresponds to the data encoding used by
--   <a>Rational</a>.
newtype PRationalData s
PRationalData :: Term s (PDataRecord '["numerator" ':= PInteger, "denominator" ':= PPositive]) -> PRationalData s

-- | Extracts the element out of a <a>PDJust</a> and throws an error if its
--   argument is <a>PDNothing</a>.
pfromDJust :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybeData a :--> a)

-- | Yield <a>PTrue</a> if a given <a>PMaybeData</a> is of the form
--   <tt><a>PDJust</a> _</tt>.
pisDJust :: forall (a :: PType) (s :: S). Term s (PMaybeData a :--> PBool)

-- | Special version of <tt>pmaybe</tt> that works with <a>PMaybeData</a>.
pmaybeData :: forall (a :: PType) (b :: PType) (s :: S). PIsData a => Term s (b :--> ((a :--> b) :--> (PMaybeData a :--> b)))

-- | Construct a <a>PDJust</a> value.
pdjust :: forall (a :: PType) (s :: S). PIsData a => Term s (a :--> PMaybeData a)

-- | Construct a <a>PDNothing</a> value.
pdnothing :: forall (a :: PType) (s :: S). Term s (PMaybeData a)

-- | Construct a <a>PMaybeData</a> given a <a>PMaybe</a>. Could be useful
--   if you want to "lift" from <a>PMaybe</a> to <a>Maybe</a>.
pmaybeToMaybeData :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybe a :--> PMaybeData a)

-- | Extract the value stored in a <a>PMaybeData</a> container. If there's
--   no value, throw an error with the given message.
passertPDJust :: forall (a :: PType) (s :: S). PIsData a => Term s (PString :--> (PMaybeData a :--> a))

prationalFromData :: ClosedTerm (PRationalData :--> PRational)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.Show.PShow Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.Bool.PEq Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V2.PTxInInfo
instance GHC.Generics.Generic (Plutarch.LedgerApi.V2.PTxInInfo s)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.Show.PShow Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.Bool.PEq Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V2.PTxInfo
instance GHC.Generics.Generic (Plutarch.LedgerApi.V2.PTxInfo s)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.V2.PScriptContext
instance Plutarch.Show.PShow Plutarch.LedgerApi.V2.PScriptContext
instance Plutarch.Bool.PEq Plutarch.LedgerApi.V2.PScriptContext
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.LedgerApi.V2.PScriptContext
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.V2.PScriptContext
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V2.PScriptContext
instance GHC.Generics.Generic (Plutarch.LedgerApi.V2.PScriptContext s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V2.Contexts.TxInInfo
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V2.Contexts.TxInfo
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V2.Contexts.ScriptContext
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.V2.PScriptContext
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.V2.PScriptContext
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.V2.PScriptContext)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.V2.PTxInfo)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.V2.PTxInInfo)

module Plutarch.LedgerApi.V1

data PScriptPurpose (s :: S)
PMinting :: Term s (PDataRecord '["_0" ':= PCurrencySymbol]) -> PScriptPurpose (s :: S)
PSpending :: Term s (PDataRecord '["_0" ':= PTxOutRef]) -> PScriptPurpose (s :: S)
PRewarding :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PScriptPurpose (s :: S)
PCertifying :: Term s (PDataRecord '["_0" ':= PDCert]) -> PScriptPurpose (s :: S)

newtype PScriptContext (s :: S)
PScriptContext :: Term s (PDataRecord '["txInfo" ':= PTxInfo, "purpose" ':= PScriptPurpose]) -> PScriptContext (s :: S)

data PDCert (s :: S)
PDCertDelegRegKey :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDeRegKey :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDelegate :: Term s (PDataRecord '["_0" ':= PStakingCredential, "_1" ':= PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRegister :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRetire :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PInteger]) -> PDCert (s :: S)
PDCertGenesis :: Term s (PDataRecord '[]) -> PDCert (s :: S)
PDCertMir :: Term s (PDataRecord '[]) -> PDCert (s :: S)

data PCredential (s :: S)
PPubKeyCredential :: Term s (PDataRecord '["_0" ':= PPubKeyHash]) -> PCredential (s :: S)
PScriptCredential :: Term s (PDataRecord '["_0" ':= PScriptHash]) -> PCredential (s :: S)

data PStakingCredential (s :: S)
PStakingHash :: Term s (PDataRecord '["_0" ':= PCredential]) -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PInteger, "_2" ':= PInteger]) -> PStakingCredential (s :: S)

newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)

data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees

newtype PLovelace (s :: S)
PLovelace :: Term s (PDataNewtype PInteger) -> PLovelace (s :: S)

newtype PTokenName (s :: S)
PTokenName :: Term s (PDataNewtype PByteString) -> PTokenName (s :: S)

newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s (PDataNewtype PByteString) -> PCurrencySymbol (s :: S)

newtype PPosixTime (s :: S)
PPosixTime :: Term s (PDataNewtype PInteger) -> PPosixTime (s :: S)

-- | Construct a <a>PPosixTime</a> from a <a>PInteger</a>. Same as using
--   the constructor, but a lot shorter.
--   
--   @since WIP
pposixTime :: forall (s :: S). Term s PInteger -> Term s PPosixTime

-- | Unwrap a <a>PPosixTime</a> to get a <a>PInteger</a>. Same as using
--   <a>pmatch</a>, but a lot shorter. Also unwraps the <tt>Data</tt>
--   encoding.
--   
--   @since WIP
unPPosixTime :: forall (s :: S). Term s PPosixTime -> Term s PInteger

data PExtended (a :: S -> Type) (s :: S)
PNegInf :: Term s (PDataRecord '[]) -> PExtended (a :: S -> Type) (s :: S)
PFinite :: Term s (PDataRecord '["_0" ':= a]) -> PExtended (a :: S -> Type) (s :: S)
PPosInf :: Term s (PDataRecord '[]) -> PExtended (a :: S -> Type) (s :: S)

newtype PLowerBound (a :: S -> Type) (s :: S)
PLowerBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PBool]) -> PLowerBound (a :: S -> Type) (s :: S)

newtype PUpperBound (a :: S -> Type) (s :: S)
PUpperBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PBool]) -> PUpperBound (a :: S -> Type) (s :: S)

newtype PInterval (a :: S -> Type) (s :: S)
PInterval :: Term s (PDataRecord '["from" ':= PLowerBound a, "to" ':= PUpperBound a]) -> PInterval (a :: S -> Type) (s :: S)

newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)

newtype PRedeemer (s :: S)
PRedeemer :: Term s PData -> PRedeemer (s :: S)

newtype PDatumHash (s :: S)
PDatumHash :: Term s (PDataNewtype PByteString) -> PDatumHash (s :: S)

newtype PRedeemerHash (s :: S)
PRedeemerHash :: Term s (PDataNewtype PByteString) -> PRedeemerHash (s :: S)

newtype PScriptHash (s :: S)
PScriptHash :: Term s (PDataNewtype PByteString) -> PScriptHash (s :: S)

newtype PAddress (s :: S)
PAddress :: Term s (PDataRecord '["credential" ':= PCredential, "stakingCredential" ':= PMaybeData PStakingCredential]) -> PAddress (s :: S)

-- | Hashed with <tt>BLAKE2b-256</tt>.
newtype PTxId (s :: S)
PTxId :: Term s (PDataRecord '["_0" ':= PByteString]) -> PTxId (s :: S)

newtype PTxOut (s :: S)
PTxOut :: Term s (PDataRecord '["address" ':= PAddress, "value" ':= PValue 'Sorted 'Positive, "datumHash" ':= PDatumHash]) -> PTxOut (s :: S)

newtype PTxInInfo (s :: S)
PTxInInfo :: Term s (PDataRecord '["outRef" ':= PTxOutRef, "resolved" ':= PTxOut]) -> PTxInInfo (s :: S)

-- | Reference to a transaction output, with an index referencing which
--   exact output we mean.
newtype PTxOutRef (s :: S)
PTxOutRef :: Term s (PDataRecord '["id" ':= PTxId, "idx" ':= PInteger]) -> PTxOutRef (s :: S)

newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s (PDataNewtype PByteString) -> PPubKeyHash (s :: S)

-- | @since WIP
newtype PTxInfo (s :: S)
PTxInfo :: Term s (PDataRecord '["inputs" ':= PBuiltinList (PAsData PTxInInfo), "outputs" ':= PBuiltinList (PAsData PTxOut), "fee" ':= PValue 'Sorted 'Positive, "mint" ':= PValue 'Sorted 'NoGuarantees, "dCert" ':= PBuiltinList (PAsData PDCert), "wdrl" ':= PBuiltinList (PAsData (PBuiltinPair (PAsData PStakingCredential) (PAsData PInteger))), "validRange" ':= PInterval PPosixTime, "signatories" ':= PBuiltinList (PAsData PPubKeyHash), "data" ':= PBuiltinList (PAsData (PBuiltinPair (PAsData PDatumHash) (PAsData PDatum))), "id" ':= PTxId]) -> PTxInfo (s :: S)

newtype PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)

data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees

data Commutativity
Commutative :: Commutativity
NonCommutative :: Commutativity

-- | @since WIP
data PMaybeData (a :: S -> Type) (s :: S)
PDJust :: Term s (PAsData a) -> PMaybeData (a :: S -> Type) (s :: S)
PDNothing :: PMaybeData (a :: S -> Type) (s :: S)

-- | A Rational type that corresponds to the data encoding used by
--   <a>Rational</a>.
newtype PRationalData s
PRationalData :: Term s (PDataRecord '["numerator" ':= PInteger, "denominator" ':= PPositive]) -> PRationalData s

-- | Extracts the element out of a <a>PDJust</a> and throws an error if its
--   argument is <a>PDNothing</a>.
pfromDJust :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybeData a :--> a)

-- | Yield <a>PTrue</a> if a given <a>PMaybeData</a> is of the form
--   <tt><a>PDJust</a> _</tt>.
pisDJust :: forall (a :: PType) (s :: S). Term s (PMaybeData a :--> PBool)

-- | Special version of <tt>pmaybe</tt> that works with <a>PMaybeData</a>.
pmaybeData :: forall (a :: PType) (b :: PType) (s :: S). PIsData a => Term s (b :--> ((a :--> b) :--> (PMaybeData a :--> b)))

-- | Construct a <a>PDJust</a> value.
pdjust :: forall (a :: PType) (s :: S). PIsData a => Term s (a :--> PMaybeData a)

-- | Construct a <a>PDNothing</a> value.
pdnothing :: forall (a :: PType) (s :: S). Term s (PMaybeData a)

-- | Construct a <a>PMaybeData</a> given a <a>PMaybe</a>. Could be useful
--   if you want to "lift" from <a>PMaybe</a> to <a>Maybe</a>.
pmaybeToMaybeData :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybe a :--> PMaybeData a)

-- | Extract the value stored in a <a>PMaybeData</a> container. If there's
--   no value, throw an error with the given message.
passertPDJust :: forall (a :: PType) (s :: S). PIsData a => Term s (PString :--> (PMaybeData a :--> a))

prationalFromData :: ClosedTerm (PRationalData :--> PRational)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.V1.PTxOut
instance Plutarch.Show.PShow Plutarch.LedgerApi.V1.PTxOut
instance Plutarch.Bool.PEq Plutarch.LedgerApi.V1.PTxOut
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.V1.PTxOut
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V1.PTxOut
instance GHC.Generics.Generic (Plutarch.LedgerApi.V1.PTxOut s)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.V1.PTxInInfo
instance Plutarch.Show.PShow Plutarch.LedgerApi.V1.PTxInInfo
instance Plutarch.Bool.PEq Plutarch.LedgerApi.V1.PTxInInfo
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.V1.PTxInInfo
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V1.PTxInInfo
instance GHC.Generics.Generic (Plutarch.LedgerApi.V1.PTxInInfo s)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.Show.PShow Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.Bool.PEq Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V1.PTxInfo
instance GHC.Generics.Generic (Plutarch.LedgerApi.V1.PTxInfo s)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.LedgerApi.V1.PScriptContext
instance Plutarch.Show.PShow Plutarch.LedgerApi.V1.PScriptContext
instance Plutarch.Bool.PEq Plutarch.LedgerApi.V1.PScriptContext
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.LedgerApi.V1.PScriptContext
instance Plutarch.Builtin.PIsData Plutarch.LedgerApi.V1.PScriptContext
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V1.PScriptContext
instance GHC.Generics.Generic (Plutarch.LedgerApi.V1.PScriptContext s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Tx.TxOut
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.TxInInfo
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.TxInfo
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.ScriptContext
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.V1.PScriptContext
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.V1.PScriptContext
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.V1.PScriptContext)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.V1.PTxInfo)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.V1.PTxInInfo
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.V1.PTxInInfo
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.V1.PTxInInfo)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.LedgerApi.V1.PTxOut
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.LedgerApi.V1.PTxOut
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.LedgerApi.V1.PTxOut)
